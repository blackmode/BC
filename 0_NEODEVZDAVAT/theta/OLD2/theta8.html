<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - dual fisheye panorama</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
         <script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
         <script type="text/javascript" src="../src/js/lib.js"></script>
         <script type="text/javascript" src="../src/js/Externallib.js"></script>

    </head>

    <style type="text/css">
        body {
            margin: 0px;
            padding: 0px;
            border: 0px solid blue;
            width: auto;
            height: auto;
        }
 

    </style>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec3 pos;
        attribute vec2 texture;

        uniform mat4 MMatrix;
        uniform mat4 VMatrix;
        uniform mat4 PMatrix;

        varying vec2 varyingTexture;
            
        void main(void) {
            gl_Position = PMatrix * VMatrix * MMatrix * vec4(pos, 1.0);
            varyingTexture = texture;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 varyingTexture;
        uniform sampler2D sampler;  
            
        void main(void) {
            gl_FragColor = vec4(1, 0.5, 0.4, 1); 
            gl_FragColor = texture2D(sampler, varyingTexture);
            
        }
    </script>



    <body onload="main()">
 
        <canvas id="glcanvas" width="480" height="320"></canvas>
      <video preload="auto" id="video" loop="false" webkit-playsinline crossOrigin="anonymous" style="    width: 480px; height: 320px " controls muted>
        <!--<source src="data/firefox.ogv" type="video/mp4">-->
        <source src="data/theta3.mp4" type="video/mp4">
      </video>

    </body>



    <script>

        var rotation = 0.00;
        var down = 0.00;
        var up = 0.00;
var mmatrix = mat4.create();
var vmatrix = mat4.create();
var pmatrix = mat4.create();
var mmLoc;
var texture;
 var canvas = document.querySelector("canvas");
 
 
var GEOMETRY = createSphereGeometry(36,30,7.0);
var vertexPositionData = GEOMETRY.vertices;
var normalData = GEOMETRY.normals;
var textureCoordData =GEOMETRY.textures;
var indexData = GEOMETRY.indices;


        var gl = canvas.getContext("experimental-webgl");
        /*
                        var video = document.createElement( 'video' );
                        video.width = 60;
                        video.height = 40;
                        video.loop = true;
                        video.muted = true;
                        video.src = getParamByKey('video') ? getParamByKey('video') : "data/theta2.mp4";
                        video.setAttribute( 'webkit-playsinline', 'webkit-playsinline' );
                        //video.play();
*/
var video = document.getElementById('video');
 

// load the video, and play on ready
video.load();
video.oncanplaythrough = function() {
    if (this.readyState >= video.HAVE_CURRENT_DATA )
            this.play();
  console.log('OnCANPLAYthrough');
  render();
};



    function initProgram() {






            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );

            var str = document.querySelector("#vs").textContent;
            var vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, str);
            gl.compileShader(vs);
                
            var str = document.querySelector("#fs").textContent;
            var fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, str);
            gl.compileShader(fs);

            var program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            
            // -------- ZOBRAZOVACI matice
            mat4.scale(mmatrix, mmatrix, vec3.fromValues(0.3, 0.3, 0.3));
            mmLoc = gl.getUniformLocation(program, "MMatrix");

            
            mat4.translate(vmatrix, vmatrix, vec3.fromValues(0, 0, 0));
            var vmLoc = gl.getUniformLocation(program, "VMatrix");
            gl.uniformMatrix4fv(vmLoc, false, vmatrix);

            
            mat4.perspective(pmatrix, Math.PI/2.5, 1.75, 0.1, 100);
            var pmLoc = gl.getUniformLocation(program, "PMatrix");
            gl.uniformMatrix4fv(pmLoc, false, pmatrix);

            var samplerLoc = gl.getUniformLocation(program, "sampler");
            gl.uniform1i(samplerLoc, 0);


            // -------- atributy
            var posLoc = gl.getAttribLocation(program, "pos");
            gl.enableVertexAttribArray(posLoc);

            var textureLoc = gl.getAttribLocation(program, "texture");
            gl.enableVertexAttribArray(textureLoc);


            // -------- BUFFERY
            var  vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, (vertexPositionData), gl.STATIC_DRAW);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            
            var textureBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, (textureCoordData), gl.STATIC_DRAW);
            gl.vertexAttribPointer(textureLoc, 2, gl.FLOAT, false, 0, 0);

            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (indexData), gl.STATIC_DRAW);

 

            // otoceni kamery do pocatecni pozice
          // mat4.rotateX(mmatrix, mmatrix,  Math.PI/2);
           //gl.uniformMatrix4fv(mmLoc, false, mmatrix);



texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
//gl.bindTexture(gl.TEXTURE_2D, null);


    }

function isPowerOfTwo(x) {
    return (x & (x - 1)) == 0;
}

function nextHighestPowerOfTwo(x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
}
function updateTexture() {

  if (video.readyState >= video.HAVE_CURRENT_DATA ) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      // the next line fails in Safari if the video is coming from another domain or subdomain

        if (!isPowerOfTwo(video.width) || !isPowerOfTwo(video.height)) {
            // Scale up the texture to the next highest power of two dimensions.
            var canvas = document.createElement("canvas");
            canvas.width = nextHighestPowerOfTwo(video.width);
            canvas.height = nextHighestPowerOfTwo(video.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, video.width, video.height);
            video = canvas;
        }
       gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,gl.UNSIGNED_BYTE, video);
      gl.bindTexture(gl.TEXTURE_2D, null);

   }

}




        function render() {
             updateTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

              mat4.rotateZ(mmatrix, mmatrix, rotation);
             gl.uniformMatrix4fv(mmLoc, false, mmatrix);
            /// ROTACNI MATICE
                mat4.rotateY(mmatrix, mmatrix, down);
                gl.uniformMatrix4fv(mmLoc, false, mmatrix);

                mat4.rotateY(mmatrix, mmatrix, up);
                gl.uniformMatrix4fv(mmLoc, false, mmatrix);

            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, indexData.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }

        window.requestAnimationFrame = window.requestAnimationFrame 
            || window.mozRequestAnimationFrame
            || window.webkitRequestAnimationFrame
            || function(cb) { setTimeout(cb, 1000/60); };

        function onDocumentMouseMove( event ) {
            console.log( event.clientY/200000);
            rotation = event.clientY/200000
        }

        function onDocumentMouseDown( event ) {
            down = -event.clientY/20000;
        }

        function onDocumentMouseUp( event ) {
            up = event.clientY/20000;
        }



        function main() {
            DebugThreeStat();
            initProgram();
            render();
        }
 

    </script>



</html>

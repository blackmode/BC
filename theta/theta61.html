<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - dual fisheye panorama</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		 <script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
		 <script type="text/javascript" src="../src/js/lib.js"></script>
		 <script type="text/javascript" src="../src/js/Externallib.js"></script>

	</head>

	<style type="text/css">
		body {
			margin: 0px;
			padding: 0px;
			border: 0px solid blue;
			width: auto;
			height: auto;
		}
 

	</style>

	<script id="vs" type="x-shader/x-vertex">
		attribute vec3 pos;
		attribute vec2 texture;

		uniform mat4 MMatrix;
		uniform mat4 VMatrix;
		uniform mat4 PMatrix;

		varying vec2 varyingTexture;
			
		void main(void) {
			gl_Position = PMatrix * VMatrix * MMatrix * vec4(pos, 1.0);
			varyingTexture = texture;
 

		}
	</script>

	<script id="fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec2 varyingTexture;
		uniform sampler2D sampler;  
			
		void main(void) {
			 gl_FragColor = texture2D(sampler, varyingTexture);
			 if (varyingTexture.x <  0.5  ) {
 

			   gl_FragColor.a  = 0.87;

			 }
			
		}
	</script>



	<body onload="main()">
	<!--
 	  <video preload="auto" id="video" loop="false" webkit-playsinline crossOrigin="anonymous" style="    width: 800px; height: 600px " controls muted autoplay>
		 <source src="data/firefox.ogv" type="video/mp4"> 
		<source src="data/theta2.mp4" type="video/mp4">
	  </video> -->

		<canvas id="glcanvas" width="800" height="600"></canvas>
		<div id="data"></div>
	</body>



	<script>
function createSphereGeometry (latitudeBands, longitudeBands, radius, noIndices) 
{
	var vertices = [];
	var textures = [];
	var normals = [];
	var indices = [];

	var rad = 180/Math.PI;

	var sin = function (angle) {
		return Math.sin(angle);  
	}

	var cos = function (angle) {
		return Math.cos(angle);  
	}


	var resolution_width = 1920;
	var resolution_height = 1080;

	var fisheye_1_x_begin = 17;
	var fisheye_1_x_end = 921;
	var fisheye_1_y_begin = 134;
	var fisheye_1_y_end = 1053;

	var fisheye_2_x_begin = 960;
	var fisheye_2_x_end = 1861;
	var fisheye_2_y_begin = 133;
	var fisheye_2_y_end = 1063;

	var latitude_width = resolution_height/latitudeBands ;
	var longitude_width = resolution_width/longitudeBands;

	var latitudeAngle =  Math.PI / latitudeBands;         // 0°-180°
	var longitudeAngle =  2 * Math.PI / longitudeBands;  //  0°-360°

	for (var latNumber = 0; latNumber <= latitudeBands; ++latNumber) {  // zde ukazuje na ktere jsme rovnobezce
		var theta = latNumber * latitudeAngle;



		for (var longNumber = 0; longNumber <= longitudeBands; ++ longNumber) {// zde ukazuje na kterym jsme poledniku

			var phi = longNumber * longitudeAngle;

			// vrcholy
			var x = sin(theta) * cos(phi) * radius;
			var y = sin(phi) * sin(theta) * radius;
			var z = cos(theta) * radius;

			// normaly
			var normals_x = x/radius;
			var normals_y = y/radius;
			var normals_z = z/radius;

			// textury
			u= longNumber/longitudeBands;
			v= latNumber/latitudeBands;

			// pridame vrcholy
			vertices.push(x);
			vertices.push(y);
			vertices.push(z);

			// pridame normaly (vektory)
			normals.push(normals_x);
			normals.push(normals_y);
			normals.push(normals_z);

			// koordiunace textury
			textures.push(u);
			textures.push(v);
		}

	}

 

	for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
	  for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
		var first = (latNumber * (longitudeBands + 1)) + longNumber;
		var second = first + longitudeBands + 1;
		indices.push(first);
		indices.push(second);
		indices.push(first + 1);

		indices.push(second);
		indices.push(second + 1);
		indices.push(first + 1);
	  }
	}


	if (noIndices){

				// data uravuju tak, aby to tak funkce prelouskala
				textures.itemSize = 2;
				normals.itemSize = 3;
				vertices.itemSize = 3;

				var data = {
					textures : {
						itemSize: 2,
						array: textures
					} ,
					indices : {
						array: indices
					} ,
					normals : {
						itemSize: 3,
						array: normals
					} ,
					position : {
						itemSize: 3,
						array: vertices
					} 
				};

				var data2 = {

				};
		 
				// TOHLE JE FUNKCE Z THREE.JS, udela to to, ze to prepocita indexy na vrcholy, k tomu to prepocita i dalsi veci jako textury apod
				//var indices = indices;
				var attributes = data;
				for ( var name in attributes ) {

					var attribute = attributes[ name ];

					var array = attribute.array;

					var itemSize = attribute.itemSize;
					var array2 = initArray(  indices.length * itemSize );
					var index = 0, index2 = 0;

					for ( var i = 0, l = indices.length ; i < l; i ++ ) {

						index = indices[ i ] * itemSize;

						for ( var j = 0; j < itemSize; j ++ ) {

							array2[ index2 ++ ] = array[ index ++ ];

						}

					}
					data2 [name] = {array : array2, itemSize : itemSize};
					//geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
	 
				}
		 
				textures = data2.textures.array;
				vertices = data2.position.array;
				normals = data2.normals.array;


				// Zde se provadi korekce
				for ( var i = 0, l = normals.length / 3; i < l; i ++ ) {

					var x = normals[ i * 3 + 0 ];
					var z = normals[ i * 3 + 1 ];
					var y = normals[ i * 3 + 2 ];

					if ( i < l / 2 ) {
						var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
						textures[ i * 2 + 0 ]  = x*( 410 / 1920 )*correction + ( 447 / 1920 ) + 0.0071;   //  x * ( 404 / 1920 )*correction  + ( 447 / 1920 ) ;
						textures[ i * 2 + 1 ] = z  * ( 410 / 1080 )*correction  + ( 520 / 1080 )- 0.035 ; // z * ( 404 / 1080 )*correction   + ( 582 / 1080 ) ;
					if (0) {
					textures[ i * 2 + 0 ]  =0;
					textures[ i * 2 + 1 ]  = 0;
					}


					} else {
						var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( - y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
						textures[ i * 2 + 0 ] =   -x * ( 410 / 1920 )*correction      + ( 1470 / 1920 )-0.00775 ;
						textures[ i * 2 + 1 ] =   z * ( 406 / 1080 )*correction   + ( 506 / 1080 )  ;
 

					}

				}
	}

 

	return {
		vertices: new Float32Array(vertices),
		textures: new Float32Array(textures),
		normals: new Float32Array(normals),
		indices: new Uint16Array(indices),
		noIndices: noIndices,
	};
};


 
var mmatrix = createIdentityMatrix4();
var vmatrix = createIdentityMatrix4();
var pmatrix = createIdentityMatrix4();

 
var GEOMETRY = createSphereGeometry(40,40,7.0,1) ;
var vertexPositionData = GEOMETRY.vertices;
var normalData = GEOMETRY.normals;
var textureCoordData =GEOMETRY.textures;
var indexData = GEOMETRY.indices;

 
var mouse = {
	position : {
		x: 0.0,
		y: 0.0,
	} ,
	down : {
		x: 0.0,
		y: 0.0,
	} ,
	up : {
		x: 0.0,
		y: 0.0,
	} ,
	move : {
		x: 0.0,
		y: 0.0,
	} ,

	lat : 0.0,
	lon : 0.0,
	active : false,
};

 


var indexBuffer;
var program ;
var samplerLoc ;
var vertexBuffer;
var mmLoc;
var texture;
var canvas = document.querySelector("canvas");
var gl =  canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
if (!gl) {
	w('Webgl se nepodarilo inicializovat...');
}

var video = createVideo("data/theta2.mp4");

 

video.oncanplaythrough = function() {
	render();
	//video.play();
};

/*
video.addEventListener("timeupdate", function(){
    if(this.currentTime >= 8){
        this.pause();
    }
});
*/

 
video.addEventListener("loadedmetadata",function() { 
	this.currentTime = (getParamByKey("time") ? getParamByKey("time") : 8.4) ;
},false);
 

	function initProgram() {

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener("keypress", onDocumentKeyPress, false);

			// nacteni, zkompilovani a overeni vertext shaderu
			var str = document.querySelector("#vs").textContent;
			var vs = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vs, str);
			gl.compileShader(vs);
			var vertextSucces = gl.getShaderParameter(vs, gl.COMPILE_STATUS);
			if (!vertextSucces) {
				w('nepodařilo se zkompilovat VERTEX_SHADER');
				return false;
			}
			
			// nacteni, zkompilovani a overeni fragment shaderu
			var str = document.querySelector("#fs").textContent;
			var fs = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fs, str);
			gl.compileShader(fs);
			var fragmentSucces = gl.getShaderParameter(fs, gl.COMPILE_STATUS);
			if (!fragmentSucces) {
				w('nepodařilo se zkompilovat FRAGMENT_SHADER');
				return false;
			}

			// vytvoreni programu, pridani vertex a fragment shaderu a overeni
			program = gl.createProgram();
			gl.attachShader(program, vs);
			gl.attachShader(program, fs);
			gl.linkProgram(program);
			gl.useProgram(program);
			var programSuccess = gl.getProgramParameter( program, gl.LINK_STATUS);
			if ( ! programSuccess) {
			  var info = gl.getProgramInfoLog(program);
			  w ('nepodařilo se zkompilovat WebGL program. \n\n' + info);
			  return false;
			}
			
			// -------- ZOBRAZOVACI matice
			mat4.scale(mmatrix, mmatrix, vec3.fromValues(0.3, 0.3, 0.3));
			mmLoc = gl.getUniformLocation(program, "MMatrix");

			
			mat4.translate(vmatrix, vmatrix, vec3.fromValues(0, 0, -3.9));
			var vmLoc = gl.getUniformLocation(program, "VMatrix");
			gl.uniformMatrix4fv(vmLoc, false, vmatrix);

			
			mat4.perspective(pmatrix, Math.PI/2.5, 1.3, 0.1, 100);
			var pmLoc = gl.getUniformLocation(program, "PMatrix");
			gl.uniformMatrix4fv(pmLoc, false, pmatrix);

			samplerLoc = gl.getUniformLocation(program, "sampler");
			gl.uniform1i(samplerLoc, 0);


			// -------- atributy
			var posLoc = gl.getAttribLocation(program, "pos");
			gl.enableVertexAttribArray(posLoc);

			var textureLoc = gl.getAttribLocation(program, "texture");
			gl.enableVertexAttribArray(textureLoc);


			// -------- BUFFERY
			vertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, (vertexPositionData), gl.STATIC_DRAW);
			gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
			

			var textureBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, (textureCoordData), gl.STATIC_DRAW);
			gl.vertexAttribPointer(textureLoc, 2, gl.FLOAT, false, 0, 0);

			indexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (indexData), gl.STATIC_DRAW);

			// ---- NASTAVENI
			//gl.disable(gl.DEPTH_TEST);
			gl.enable(gl.DEPTH_TEST);
			//gl.clearColor(0, 0, 0, 1);

			 //gl.enable(gl.BLEND);
			//gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


			// ---- otoceni kamery do pocatecni pozice
			mat4.rotateZ(mmatrix, mmatrix,  - Math.PI/2 );
			gl.uniformMatrix4fv(mmLoc, false, mmatrix);

			mat4.rotateX(mmatrix, mmatrix, -Math.PI/2);
			gl.uniformMatrix4fv(mmLoc, false, mmatrix);

			mat4.rotateX(mmatrix, mmatrix,    Math.PI  /2 );
			gl.uniformMatrix4fv(mmLoc, false, mmatrix);

			mat4.rotateX(mmatrix, mmatrix,    Math.PI/2 );
			gl.uniformMatrix4fv(mmLoc, false, mmatrix);


			// ----- VYTVORENI TEXTURY
			texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

			gl.bindTexture(gl.TEXTURE_2D, null);
	}

 
	function updateTexture() {

	  if (video.readyState >= video.HAVE_CURRENT_DATA ) {
		  gl.activeTexture(gl.TEXTURE0);
		  gl.bindTexture(gl.TEXTURE_2D, texture);
		  //gl.pixelStorei(gl.UNPACK_FLIP_X_WEBGL, true);
		  // the next line fails in Safari if the video is coming from another domain or subdomain
		  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,gl.UNSIGNED_BYTE, video);
		  gl.bindTexture(gl.TEXTURE_2D, null);
	  }
	}


		function render() {
			var elem = document.getElementById("data").innerHTML = 'Čas: '+video.currentTime ;
			 updateTexture();
			 
			  // mat4.rotateX(mmatrix, mmatrix, rotation);
			  //gl.uniformMatrix4fv(mmLoc, false, mmatrix);
			/// ROTACNI MATICE
 


			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.uniform1i(samplerLoc, 0);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

			// zde prepinanim renderovani
			if (!GEOMETRY.noIndices) {
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				gl.drawElements(gl.TRIANGLES, indexData.length, gl.UNSIGNED_SHORT, 0);
			}
			else {
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);// HAZI TO VIC CHYB, nevim  jeste proc
				gl.drawArrays(gl.TRIANGLES,0, normalData.length/3);
			}
			requestAnimationFrame(render);
		}

		window.requestAnimationFrame = window.requestAnimationFrame 
			|| window.mozRequestAnimationFrame
			|| window.webkitRequestAnimationFrame
			|| function(cb) { setTimeout(cb, 1000/60); };



		function onDocumentMouseDown( event ) {
			mouse.active = true;
			mouse.down.x = event.clientX;
			mouse.down.y = event.clientY;
		}

		function onDocumentMouseMove( event ) {
  
			if (mouse.active) {
				if (mouse.up.x!=event.clientX) {
					mouse.lon = (mouse.down.x - event.clientX) * 0.01 + mouse.lon;
					mouse.lon = mouse.lon / 80;

					//mat4.rotateX(mmatrix, mmatrix,    mouse.lon );
					//gl.uniformMatrix4fv(mmLoc, false, mmatrix);

				}

				if (mouse.up.y!=event.clientY) {
					mouse.lat = (mouse.down.y - event.clientY) * 0.01 + mouse.lat;
					mouse.lat = (mouse.lat / 80) *-1;

	 				mat4.rotateZ(mmatrix, mmatrix,    mouse.lat );
					gl.uniformMatrix4fv(mmLoc, false, mmatrix);

				}
			}

		}

		function onDocumentMouseUp( event ) {
			mouse.up.x = event.clientX;
			mouse.up.y = event.clientY;
			mouse.active = false;
		}

		function onDocumentKeyPress( event ) {
 			if (event.keyCode == 113 || event.keyCode == 81) { // q/Q
				video.play();
 			}
			if (event.keyCode == 119 || event.keyCode == 87  ) { // q/Q
				video.pause();
			}
		}



		function main() {
			DebugThreeStat();
			initProgram();
			render();
		}
 

	</script>



</html>

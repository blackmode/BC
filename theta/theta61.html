<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - dual fisheye panorama</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
         <script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
         <script type="text/javascript" src="../src/js/lib.js"></script>
         <script type="text/javascript" src="../src/js/Externallib.js"></script>

    </head>

    <style type="text/css">
        body {
            margin: 0px;
            padding: 0px;
            border: 0px solid blue;
            width: auto;
            height: auto;
        }
 

    </style>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec3 pos;
        attribute vec2 texture;

        uniform mat4 MMatrix;
        uniform mat4 VMatrix;
        uniform mat4 PMatrix;

        varying vec2 varyingTexture;
            
        void main(void) {
            gl_Position = PMatrix * VMatrix * MMatrix * vec4(pos, 1.0);
            varyingTexture = texture;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 varyingTexture;
        uniform sampler2D sampler;  
            
        void main(void) {
             gl_FragColor = texture2D(sampler, varyingTexture);
            
        }
    </script>



    <body onload="main()">
 
        <canvas id="glcanvas" width="800" height="600"></canvas>
      <video preload="auto" id="video" loop="false" webkit-playsinline crossOrigin="anonymous" style="    width: 800px; height: 600px " controls muted>
        <!--<source src="data/firefox.ogv" type="video/mp4">-->
        <source src="data/theta2.mp4" type="video/mp4">
      </video>

    </body>



    <script>
function createSphereGeometry (latitudeBands, longitudeBands, radius, noIndices) 
{
    var vertices = [];
    var textures = [];
    var normals = [];
    var indices = [];

    var rad = 180/Math.PI;

    var sin = function (angle) {
        return Math.sin(angle);  
    }

    var cos = function (angle) {
        return Math.cos(angle);  
    }


    var resolution_width = 1920;
    var resolution_height = 1080;

    var fisheye_1_x_begin = 17;
    var fisheye_1_x_end = 921;
    var fisheye_1_y_begin = 134;
    var fisheye_1_y_end = 1053;

    var fisheye_2_x_begin = 960;
    var fisheye_2_x_end = 1861;
    var fisheye_2_y_begin = 133;
    var fisheye_2_y_end = 1063;

    var latitude_width = resolution_height/latitudeBands ;
    var longitude_width = resolution_width/longitudeBands;

    var latitudeAngle =  Math.PI / latitudeBands;         // 0째-180째
    var longitudeAngle =  2 * Math.PI / longitudeBands;  //  0째-360째

    for (var latNumber = 0; latNumber <= latitudeBands; ++latNumber) {  // zde ukazuje na ktere jsme rovnobezce
        var theta = latNumber * latitudeAngle;



        for (var longNumber = 0; longNumber <= longitudeBands; ++ longNumber) {// zde ukazuje na kterym jsme poledniku

            var phi = longNumber * longitudeAngle;

            // vrcholy
            var x = sin(theta) * cos(phi) * radius;
            var y = sin(phi) * sin(theta) * radius;
            var z = cos(theta) * radius;

            // normaly
            var normals_x = x/radius;
            var normals_y = y/radius;
            var normals_z = z/radius;

            // textury
            u= longNumber/longitudeBands;
            v= latNumber/latitudeBands;

            // pridame vrcholy
            vertices.push(x);
            vertices.push(y);
            vertices.push(z);

            // pridame normaly (vektory)
            normals.push(normals_x);
            normals.push(normals_y);
            normals.push(normals_z);

            // koordiunace textury
            textures.push(u);
            textures.push(v);




            // zde zpracovavam index data
            /*if (latNumber  < latitudeBands || longNumber <  longitudeBands) 
            {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indices.push(first);
                indices.push(second);
                indices.push(first + 1);

                indices.push(second);
                indices.push(second + 1);
                indices.push(first + 1);
            }*/

        }

    }

 

    for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
      for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
        var first = (latNumber * (longitudeBands + 1)) + longNumber;
        var second = first + longitudeBands + 1;
        indices.push(first);
        indices.push(second);
        indices.push(first + 1);

        indices.push(second);
        indices.push(second + 1);
        indices.push(first + 1);
      }
    }


    if (noIndices){

                // data uravuju tak, aby to tak funkce prelouskala
                textures.itemSize = 2;
                normals.itemSize = 3;
                vertices.itemSize = 3;

                var data = {
                    textures : {
                        itemSize: 2,
                        array: textures
                    } ,
                    indices : {
                        array: indices
                    } ,
                    normals : {
                        itemSize: 3,
                        array: normals
                    } ,
                    position : {
                        itemSize: 3,
                        array: vertices
                    } 
                };

                var data2 = {

                };
         
                // TOHLE JE FUNKCE Z THREE.JS, udela to to, ze to prepocita indexy na vrcholy, k tomu to prepocita i dalsi veci jako textury apod
                //var indices = indices;
                var attributes = data;
                for ( var name in attributes ) {

                    var attribute = attributes[ name ];

                    var array = attribute.array;

                    var itemSize = attribute.itemSize;
                    var array2 = initArray(  indices.length * itemSize );
                    var index = 0, index2 = 0;

                    for ( var i = 0, l = indices.length ; i < l; i ++ ) {

                        index = indices[ i ] * itemSize;

                        for ( var j = 0; j < itemSize; j ++ ) {

                            array2[ index2 ++ ] = array[ index ++ ];

                        }

                    }
                    data2 [name] = {array : array2, itemSize : itemSize};
                    //geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
     
                }
         
                textures = data2.textures.array;
                vertices = data2.position.array;
                normals = data2.normals.array;


                // Zde se provadi korekce
                for ( var i = 0, l = normals.length / 3; i < l; i ++ ) {

                    var x = normals[ i * 3 + 0 ];
                    var z = normals[ i * 3 + 1 ];
                    var y = normals[ i * 3 + 2 ];

                    if ( i < l / 2 ) {
                        var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
                        textures[ i * 2 + 0 ]  = x*( 430 / 1920 )*correction + ( 447 / 1920 ) + 0.0071;   //  x * ( 404 / 1920 )*correction  + ( 447 / 1920 ) ;
                        textures[ i * 2 + 1 ] = z  * ( 430 / 1080 )*correction  + ( 520 / 1080 )- 0.05 ; // z * ( 404 / 1080 )*correction   + ( 582 / 1080 ) ;

                    } else {
                        var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( - y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
                        textures[ i * 2 + 0 ] =   -x * ( 430 / 1920 )*correction      + ( 1470 / 1920 )-0.00750 ;
                        textures[ i * 2 + 1 ] =  z * ( 430 / 1080 )*correction   + ( 520 / 1080 ) -0.038;


                    }

                }
    }

 

    return {
        vertices: new Float32Array(vertices),
        textures: new Float32Array(textures),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices),
        noIndices: noIndices,
    };
};


        var rotation = 0.00;
        var down = 0.00;
        var up = 0.00;
var mmatrix = mat4.create();
var vmatrix = mat4.create();
var pmatrix = mat4.create();
var mmLoc;
var texture;
 var canvas = document.querySelector("canvas");
 

 
var GEOMETRY = createSphereGeometry(20,20,7.0,1) ;
 var vertexPositionData = GEOMETRY.vertices;
var normalData = GEOMETRY.normals;
var textureCoordData =GEOMETRY.textures;
var indexData = GEOMETRY.indices;

var indexBuffer;
var program ;
var samplerLoc ;

        var gl =  canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        /*
                        var video = document.createElement( 'video' );
                        video.width = 60;
                        video.height = 40;
                        video.loop = true;
                        video.muted = true;
                        video.src = getParamByKey('video') ? getParamByKey('video') : "data/theta2.mp4";
                        video.setAttribute( 'webkit-playsinline', 'webkit-playsinline' );
                        //video.play();
*/
var video = document.getElementById('video');
 

// load the video, and play on ready
video.load();
video.oncanplaythrough = function() {

             this.play();
  console.log('OnCANPLAYthrough');
  render();
};



    function initProgram() {

            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );

            var str = document.querySelector("#vs").textContent;
            var vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, str);
            gl.compileShader(vs);
                
            var str = document.querySelector("#fs").textContent;
            var fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, str);
            gl.compileShader(fs);

            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            
            // -------- ZOBRAZOVACI matice
            mat4.scale(mmatrix, mmatrix, vec3.fromValues(0.3, 0.3, 0.3));
            mmLoc = gl.getUniformLocation(program, "MMatrix");

            
            mat4.translate(vmatrix, vmatrix, vec3.fromValues(0, 0, -1.5));
            var vmLoc = gl.getUniformLocation(program, "VMatrix");
            gl.uniformMatrix4fv(vmLoc, false, vmatrix);

            
            mat4.perspective(pmatrix, Math.PI/2.5, 1.3, 0.1, 100);
            var pmLoc = gl.getUniformLocation(program, "PMatrix");
            gl.uniformMatrix4fv(pmLoc, false, pmatrix);

            samplerLoc = gl.getUniformLocation(program, "sampler");
            gl.uniform1i(samplerLoc, 0);


            // -------- atributy
            var posLoc = gl.getAttribLocation(program, "pos");
            gl.enableVertexAttribArray(posLoc);

            var textureLoc = gl.getAttribLocation(program, "texture");
            gl.enableVertexAttribArray(textureLoc);


            // -------- BUFFERY
            var  vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, (vertexPositionData), gl.STATIC_DRAW);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            

            var textureBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, (textureCoordData), gl.STATIC_DRAW);
            gl.vertexAttribPointer(textureLoc, 2, gl.FLOAT, false, 0, 0);

            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (indexData), gl.STATIC_DRAW);

            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(1, 1, 1, 1);

            // otoceni kamery do pocatecni pozice
           mat4.rotateZ(mmatrix, mmatrix,  - Math.PI/2 );
           gl.uniformMatrix4fv(mmLoc, false, mmatrix);

                mat4.rotateX(mmatrix, mmatrix, -Math.PI/2);
                gl.uniformMatrix4fv(mmLoc, false, mmatrix);

texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.bindTexture(gl.TEXTURE_2D, null);


 
    }

 
function updateTexture() {

  if (video.readyState >= video.HAVE_CURRENT_DATA ) {
       gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      // the next line fails in Safari if the video is coming from another domain or subdomain
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,gl.UNSIGNED_BYTE, video);
      gl.bindTexture(gl.TEXTURE_2D, null);

  }

}




        function render() {
             updateTexture();
             
              //mat4.rotateX(mmatrix, mmatrix, rotation);
             //gl.uniformMatrix4fv(mmLoc, false, mmatrix);
            /// ROTACNI MATICE
                mat4.rotateX(mmatrix, mmatrix, down);
                gl.uniformMatrix4fv(mmLoc, false, mmatrix);

                mat4.rotateX(mmatrix, mmatrix, up);
                gl.uniformMatrix4fv(mmLoc, false, mmatrix);


            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(samplerLoc, 0);

            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // zde prepinanim renderovani
            if (!GEOMETRY.noIndices)
                gl.drawElements(gl.TRIANGLES, indexData.length, gl.UNSIGNED_SHORT, 0);
            else
                gl.drawArrays(gl.TRIANGLES,0, normalData.length/3);
            requestAnimationFrame(render);
        }

        window.requestAnimationFrame = window.requestAnimationFrame 
            || window.mozRequestAnimationFrame
            || window.webkitRequestAnimationFrame
            || function(cb) { setTimeout(cb, 1000/60); };

        function onDocumentMouseMove( event ) {
           // console.log( event.clientY/200000);
            rotation = event.clientY/200000
        }

        function onDocumentMouseDown( event ) {
            down = -event.clientY/20000;
        }

        function onDocumentMouseUp( event ) {
            up = event.clientY/20000;
        }



        function main() {
            DebugThreeStat();
            initProgram();
            render();
        }
 

    </script>



</html>

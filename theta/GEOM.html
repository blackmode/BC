<script>
var canvas = document.querySelector("canvas");
var gl = document.querySelector("canvas").getContext("experimental-webgl");
 		var resolution_width = 1920;
		var resolution_height = 1080;

		var fisheye_1_x_begin = 17;
		var fisheye_1_x_end = 921;
		var fisheye_1_y_begin = 134;
		var fisheye_1_y_end = 1053;

		var fisheye_2_x_begin = 960;
		var fisheye_2_x_end = 1861;
		var fisheye_2_y_begin = 133;
		var fisheye_2_y_end = 1063;


    var latitudeBands = 240;
    var longitudeBands = 240;
    var radius = 7.5;
    var vertexPositionData = [];
    var normalData = [];
    var textureCoordData = [];
    var prumer = 0.23541666666666666666666666666667;
    var aktualni_rovnobezka = 0;
    for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) { //v
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {//u
        var phi = longNumber * 2 * Math.PI / longitudeBands;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = cosPhi * sinTheta;
        var z = cosTheta;
        var y = sinPhi * sinTheta;



function BasicCorrection(u,v) {
	var min_u = fisheye_1_x_begin/resolution_width;
	var max_u = fisheye_2_x_end/resolution_width;
	var d_u = max_u-min_u;

	var min_v = (resolution_height-fisheye_2_y_end)/resolution_height;
	var max_v = (resolution_height-fisheye_1_y_begin) /resolution_height;
	var d_v = max_v-min_v;


	return {
		u: d_u*u+min_u,
		u: d_v*v+min_v,
	}

}


 
var u = (longNumber / longitudeBands);
 var v =   (latNumber / latitudeBands);
 

var r = 452/1920;
var dopocet = 0;




/*
			var diff = (prumer - (Math.sin(theta)*r));
			var d = (Math.sin(theta)*r)*2;
			u =  u+ diff  ;*/


 

 /*
	if (longNumber <= longitudeBands / 2) {

u = y* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
v = z* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);

 
 
u = u/5;
v = v/3;
u = u + 0.6;
v = v+ 0.5 ;

}

else 
{*/
	u = y* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
	v = z* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
	u = u + 0.2;
	v = v+ 0.5 ;
/*}*/




/*

 if (longNumber > longitudeBands / 4 && longNumber <= longitudeBands /2) {
 
		var diff = (prumer - (Math.sin(theta)*r));
		var d = (Math.sin(theta)*r)*2;
		u = u+ diff+d ;
	 }
*/


 
var u = (longNumber / longitudeBands);
 var v =   (latNumber / latitudeBands);
 

        normalData.push(x);
        normalData.push(y);
        normalData.push(z);
        //textureCoordData.push(u);
        //textureCoordData.push(v);
        vertexPositionData.push(radius * x);
        vertexPositionData.push(radius * y);
        vertexPositionData.push(radius * z);
      }
    }



for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) { //v
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var longNumber = 0; longNumber <= longitudeBands / 2 ; longNumber++) {//u
        var phi = longNumber * 2 * Math.PI / longitudeBands  * 2;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = cosPhi * sinTheta;
        var z = cosTheta;
        var y = sinPhi * sinTheta;



 

 
 
 
	u = y* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
	v = z* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
 
          textureCoordData.push(u);
        textureCoordData.push(v);

      }
    }

for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) { //v
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var longNumber = longitudeBands / 2 +1; longNumber <= longitudeBands  ; longNumber++) {//u
        var phi = longNumber * 2 * Math.PI / longitudeBands  * 2;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = cosPhi * sinTheta;
        var z = cosTheta;
        var y = sinPhi * sinTheta;



 

 
 
 
	u = y* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
	v = z* Math.sqrt((x*x+y*y - x*x*y*y)) / Math.sqrt(x*x+y*y);
	v = v+ 0.5 ;80
 
          textureCoordData.push(u);
        textureCoordData.push(v);

      }
    }
 


var vertexShader = gl.createShader(gl.VERTEX_SHADER);
var fra = 'attribute vec2 pos; attribute vec3 colour;varying vec3 v_color; void main(void) { gl_Position = vec4(vec2(pos.x*(2.0)-1.0, pos.y*(2.0)-1.0), 0.0, 1.0); gl_PointSize = 2.0;}';

//var fra = 'attribute vec2 pos; attribute vec3 colour;varying vec3 v_color; void main(void) { gl_Position = vec4( pos , 0.0, 1.0); gl_PointSize = 12.0;}';
gl.shaderSource(vertexShader, fra);
gl.compileShader(vertexShader);

var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, 'void main(void) {gl_FragColor = vec4(1.0, 0.4, 1.0, 1.0);}');
gl.compileShader(fragmentShader);

var program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

 
console.log(textureCoordData);

var posLoc = gl.getAttribLocation(program, "pos");
gl.enableVertexAttribArray(posLoc);

var posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(0.0, 0.0, 0.0, 1.0);

gl.clear(gl.COLOR_BUFFER_BIT);

if (textureCoordData.length!=((latitudeBands+1) * (longitudeBands+1)*2)) {
	console.warn('nerovna se pocet hodnot textur: '+textureCoordData.length+' != ' + ((latitudeBands+1) * (longitudeBands+1)*2));

}
else {
	console.log('pocet HODNOT textur OKKK!!!');
}

gl.drawArrays(gl.POINTS, 0, textureCoordData.length/2);

</script>

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - dual fisheye panorama</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				/*overflow: hidden;*/
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #000000;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align:center;
			}

			a {
				color: #0000ff;
			}

 

		</style>
	</head>
	<body id="body">
<script src="build/three.js"></script>
<script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
         <script type="text/javascript" src="../src/js/lib.js"></script>
         <script type="text/javascript" src="../src/js/Externallib.js"></script>

<canvas width="1200" height="800"></canvas>
 
<script id="vs" type="x-shader/x-vertex">
attribute vec3 pos;
attribute vec2 texture;

uniform mat4 MMatrix;
uniform mat4 VMatrix;
uniform mat4 PMatrix;

varying vec2 varyingTexture;
    
void main(void) {
	gl_Position = PMatrix * VMatrix * MMatrix * vec4(pos, 1.0);
    varyingTexture = texture;
}
</script>

<script id="fs" type="x-shader/x-fragment">
precision mediump float;

varying vec2 varyingTexture;
uniform sampler2D sampler;	
    
void main(void) {
	gl_FragColor = texture2D(sampler, varyingTexture);
}
</script>


<script>

var gl = document.querySelector("canvas").getContext("experimental-webgl");


 		var resolution_width = 1920;
		var resolution_height = 1080;

		var fisheye_1_x_begin = 17;
		var fisheye_1_x_end = 921;
		var fisheye_1_y_begin = 134;
		var fisheye_1_y_end = 1053;

		var fisheye_2_x_begin = 960;
		var fisheye_2_x_end = 1861;
		var fisheye_2_y_begin = 133;
		var fisheye_2_y_end = 1063;

// koresponduje v teto funkci s osou X
function BasicCorrection(u,v) {
	var min_u = fisheye_1_x_begin/resolution_width;
	var max_u = fisheye_2_x_end/resolution_width;
	var d_u = max_u-min_u;

	var min_v = (resolution_height-fisheye_2_y_end)/resolution_height;
	var max_v = (resolution_height-fisheye_1_y_begin) /resolution_height;
	var d_v = max_v-min_v;


	return {
		u: d_u*u+min_u,
		u: d_v*v+min_v,
	}

}



    var latitudeBands = 151;
    var longitudeBands = 151;
    var radius = 7.5;
    var vertexPositionData = [];
    var normalData = [];
    var textureCoordData = [];
    var prumer = 0.23541666666666666666666666666667;
    var aktualni_rovnobezka = 0;
    for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) { //v
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {//u
        var phi = longNumber * 2 * Math.PI / longitudeBands;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = cosPhi * sinTheta;
        var z = cosTheta;
        var y = sinPhi * sinTheta;


		var u = (longNumber / longitudeBands);
		var v =   (latNumber / latitudeBands);

        normalData.push(x);
        normalData.push(y);
        normalData.push(z);
        textureCoordData.push(u);
        textureCoordData.push(v);
        vertexPositionData.push(radius * x);
        vertexPositionData.push(radius * y);
        vertexPositionData.push(radius * z);
      }
    }

 
 	var test_rotation_Z = 0;	 


    var indexData = [];
    for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
      for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
        var first = (latNumber * (longitudeBands + 1)) + longNumber;
        var second = first + longitudeBands + 1;
        indexData.push(first);
        indexData.push(second);
        indexData.push(first + 1);

        indexData.push(second);
        indexData.push(second + 1);
        indexData.push(first + 1);
      }
    }


textureCoordData.itemSize = 2;
normalData.itemSize = 3;
vertexPositionData.itemSize = 3;

var data = {
	textures : {
		itemSize: 2,
		array: textureCoordData
	} ,
	indices : {
		array: indexData
	} ,
	normals : {
		itemSize: 3,
		array: normalData
	} ,
	position : {
		itemSize: 3,
		array: vertexPositionData
	} 
};

var data2 = {

};
 

			var indices = indexData;
			var attributes = data;
			for ( var name in attributes ) {

				var attribute = attributes[ name ];

 				var array = attribute.array;

				var itemSize = attribute.itemSize;
				var array2 = initArray(  indices.length * itemSize );
				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length ; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

 					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}
				data2 [name] = {array : array2, itemSize : itemSize};
 				//geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
 
			}
 
textureCoordData = data2.textures.array;
vertexPositionData = data2.position.array;
normalData = data2.normals.array;
 

					for ( var i = 0, l = normalData.length / 3; i < l; i ++ ) {

						var x = normalData[ i * 3 + 0 ];
						var z = normalData[ i * 3 + 1 ];
						var y = normalData[ i * 3 + 2 ];

						if ( i < l / 2 ) {
							var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
							textureCoordData[ i * 2 + 0 ]  = x*( 404 / 1920 )*correction + ( 447 / 1920 ) ;   //  x * ( 404 / 1920 )*correction  + ( 447 / 1920 ) ;
							textureCoordData[ i * 2 + 1 ] = z  * ( 404 / 1080 )*correction  + ( 520 / 1080 ) ; // z * ( 404 / 1080 )*correction   + ( 582 / 1080 ) ;

 

						} else {
							var correction = ( x == 0 && z == 0 ) ? 1 : ( Math.acos( - y ) / Math.sqrt( x * x + z * z ) ) * ( 2 / Math.PI );
							textureCoordData[ i * 2 + 0 ] =   -x * ( 404 / 1920 )*correction   + ( 1470 / 1920 ) ;
							textureCoordData[ i * 2 + 1 ] =  z * ( 404 / 1080 )*correction   + ( 520 / 1080 ) ;
 

						}

					}





var str = document.querySelector("#vs").textContent;
var vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, str);
gl.compileShader(vs);
	
var str = document.querySelector("#fs").textContent;
var fs = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fs, str);
gl.compileShader(fs);

var program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

var mmatrix = mat4.create();
mat4.scale(mmatrix, mmatrix, vec3.fromValues(-0.5, 0.5, 0.5));
var mmLoc = gl.getUniformLocation(program, "MMatrix");

var vmatrix = mat4.create();
mat4.translate(vmatrix, vmatrix, vec3.fromValues(0, 0, -7));
var vmLoc = gl.getUniformLocation(program, "VMatrix");
gl.uniformMatrix4fv(vmLoc, false, vmatrix);

var pmatrix = mat4.create();
mat4.perspective(pmatrix, Math.PI/3, 2, 0.1, 100);
var pmLoc = gl.getUniformLocation(program, "PMatrix");
gl.uniformMatrix4fv(pmLoc, false, pmatrix);

var samplerLoc = gl.getUniformLocation(program, "sampler");
gl.uniform1i(samplerLoc, 0);

gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.3, 0.3, 0.3, 1);

var texture = null;
var image = document.createElement("img");
image.crossOrigin = "anonymous";
image.src = "data/t111.jpg";
image.onload = function() {
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    //gl.generateMipmap(gl.TEXTURE_2D);
}
 
    mat4.rotateZ(mmatrix, mmatrix,   Math.PI/2 );
    gl.uniformMatrix4fv(mmLoc, false, mmatrix);
   // mat4.rotateZ(mmatrix, mmatrix,  -Math.PI/2 );
    //gl.uniformMatrix4fv(mmLoc, false, mmatrix);
     mat4.rotateX(mmatrix, mmatrix,      Math.PI     );
    gl.uniformMatrix4fv(mmLoc, false, mmatrix);


     mat4.rotateY(mmatrix, mmatrix,     Math.PI   );
    gl.uniformMatrix4fv(mmLoc, false, mmatrix);
 
 
var render = function() {
	gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    
     mat4.rotateX(mmatrix, mmatrix,  0.012 );
    gl.uniformMatrix4fv(mmLoc, false, mmatrix);
/*
     mat4.rotateY(mmatrix, mmatrix,  0.012 );
    gl.uniformMatrix4fv(mmLoc, false, mmatrix);
*/
if (test_rotation_Z){
      mat4.rotateZ(mmatrix, mmatrix,  0.012 );
     gl.uniformMatrix4fv(mmLoc, false, mmatrix);
 }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    //gl.drawElements(gl.TRIANGLES, indexData.length, gl.UNSIGNED_SHORT, 0);
    gl.drawArrays(gl.TRIANGLES,0, normalData.length/3);
    requestAnimationFrame(render);

}

window.requestAnimationFrame = window.requestAnimationFrame 
	|| window.mozRequestAnimationFrame
	|| window.webkitRequestAnimationFrame
	|| function(cb) { setTimeout(cb, 1000/60); };

 

    var posLoc = gl.getAttribLocation(program, "pos");
    gl.enableVertexAttribArray(posLoc);

    var textureLoc = gl.getAttribLocation(program, "texture");
    gl.enableVertexAttribArray(textureLoc);

    var vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
    
    var textureBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
    gl.vertexAttribPointer(textureLoc, 2, gl.FLOAT, false, 0, 0);

    var indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);

    render();
 

		</script>
	</body>
</html>

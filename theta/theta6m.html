<!DOCTYPE html>
<html lang="en">
	<head>
		<title>BC - panorama viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="../src/css/style.css">

 		 <script type="text/javascript" src="../src/js/lib.js"></script>
		 <script type="text/javascript" src="../src/js/Externallib.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	</head>

	<script id="vs" type="x-shader/x-vertex">
		attribute vec3 pos;
		attribute vec2 texture;

		uniform mat4 M_Matrix;
		uniform mat4 V_Matrix;
		uniform mat4 P_Matrix;

		varying vec2 varyingTexture;

		attribute vec3 fragPos;
		varying vec3 varyingFragPosNormal;
			
		void main(void) {
			gl_Position = P_Matrix * V_Matrix * M_Matrix * vec4(pos, 1.0);
			varyingTexture = texture;
			varyingFragPosNormal = fragPos;// musim predat normaly, abych nemusel predavati radius
 

		}
	</script>

	<script id="fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec3 varyingFragPosNormal;
		varying vec2 varyingTexture;
		uniform sampler2D sampler;  
		#define PI 3.14159265359
		#define KERNEL_LENGTH 30

		float offset[KERNEL_LENGTH];
		float weight[KERNEL_LENGTH];


		// clamp(u,v) => vraci stredni hodnotu mezi dvema vstupnimi hodnotami 

		void main(void) {
			 gl_FragColor = texture2D(sampler, varyingTexture);

		 /*

					 if (
						varyingTexture.x  >0.12 &&
						varyingTexture.x  <0.37 && 
						varyingTexture.y >0.30	&& 
						varyingTexture.y <0.57  
						); else if (varyingTexture.x <0.5){
						gl_FragColor.r =  (gl_FragColor.r * 0.1) ;
						gl_FragColor.g =  (gl_FragColor.g * 0.1) ;
						gl_FragColor.b =  (gl_FragColor.b * 0.1) ;
					 }
		*/

			//(( (1.0/cos( z2 )) / sqrt( x2 * x2 + y2 * y2 ) ) * ( 2.0 / 3.14159265359 ))

			float x2=varyingFragPosNormal.x ;
			float y2=varyingFragPosNormal.y  ;
			float z2=varyingFragPosNormal.z  ;
  

			// souradnice stredu
			float Sx = 0.0;
			float Sy = 0.0;

			float a = abs(Sx - x2);
			float b = abs(Sy - y2);
			float c = sqrt(a*a + b*b) ;
			// DEBUG===========================================



			if (c > 0.998       ) { 	// JE TAM DANA "&&c==0.0" ABY TO NEBYLO PLATNY! PAK ODDELAT!
				/*
				gl_FragColor.r =  (gl_FragColor.r * 0.1) ;
				gl_FragColor.g =  (gl_FragColor.g * 0.1) ;
				gl_FragColor.b =  (gl_FragColor.b * 0.1) ;
				*/
				//gl_FragColor = texture2D(sampler, vec2(varyingTexture)/1024.0) * 0.2270270270;
				offset[0] =  0.0;
				offset[1] =  1.0;
				offset[2] =  2.0;
				offset[3] =  3.0;
				offset[4] =  4.0;

				weight[0] =  0.2270270270;
				weight[1] =  0.1945945946;
				weight[2] =  0.1216216216;
				weight[3] =   0.0540540541;
				weight[4] =   0.0162162162;

				for (int i=1; i<5; i++) {
 
					//gl_FragColor+= texture2D(sampler, (vec2(varyingTexture)+vec2(0.0,offset[i]))/1024.0) * weight[i];
					//gl_FragColor+= texture2D(sampler, (vec2(varyingTexture)-vec2(0.0,offset[i]))/1024.0) * weight[i];
 
				}


				  //gl_FragColor.a =   0.6;
			}


			// korekce barvy
			if (varyingTexture.x< 0.5      ) {
				 // gl_FragColor.a =   0.988;
			}
			//gl_FragColor = vec4(1.0, 0.4, 1.0, 1.0);
		}
	</script>


	<body onload="main()" id="body">
 <!--
	  <video preload="auto" id="video" loop="false"  style="display: none " controls  >
		<source src="data/new/new2/R0010095.mp4" type="video/mp4">
	  </video>  -->
 
		<div id="viewer" style="position:relative ">
			<canvas id="glcanvas" width="1100" height="700"></canvas>
			<div id="compass-box"></div>
			<div id="field_vision">
				<svg>
					<path id="svg_path"></path>
				</svg>
			</div>
			<div id="video_status_bar"></div>
			<div id="video_controlls"></div>
			<div id="overlay"></div>
		</div>
		<div id="data"></div>
	</body>

<script>

var gl;
var GEOMETRY;
var vide_playing = 0;


/// ------ VSECHNY PROMENNE PRO MYS
var MOUSE = {
	down : {
		x: 0.0,
		y: 0.0,
	} ,
	move : {
		x: 0.0,
		y: 0.0,
		angle: {
			x: 0.0,
			y: 0.0,
		} ,
	} ,
	wheel : {
		sensitivity: 1.5/10,
		reduction: 1.3, // radius/4
		delta: 0.0,
		deltaMax: 0.0,
		deltaMin: 0.0,
	} ,

	active : false,
	interrupt: false,
};



/// ------ VSECHNY PROMENNE PRO KLAVESNICI
var KEYBOARD = {
	active : true,
	sensitivity : {
		x: 0.06,
		y:  0.06,
	} ,
};



/// ------ VSECHNY nastaveni PROGRAMU
var SETTINGS = {
	mode : {
		equirectangular : {
			panorama : {
				active: true,
			},
			video : {
				active: false,
			},
		} ,
		fisheye : {
			panorama : {
				active: false,
			},
			video : {
				active: false,
				latitudes: 60,
				longtitudes: 60,
				radius: 7,
			} ,
		} ,	
	},
	default : {
		canvas : {
			width: null,
			height:  null,
		} ,
	} ,
	input : {
		video: null,
		image:  null,
	} ,
	field_vision : {
		wdith: 0.06,
		height:  0.06,
		canvas_position_x:  0.06,
		canvas_position_y:  0.06,
	} ,
	compass : {
		wdith: 0.06,
		height:  0.06,
		canvas_position_x:  0.06,
		canvas_position_y:  0.06,
		north: 0.0,
		angle: 0.0
	} ,
	video_controlls : {
		created: null,
	} ,


};



/// ------ VSECHNY promenne PROGRAMU
var PROG = {

	shader : {
		equirectangular : {
			panorama: null,
			video: null,
		} ,
	},

	// BUFFERY programu
	buffer : {
		normal: null,
		index: null,
		vertex: null,
		texture: null,
	} ,

	// ATRIBUTY programu
	attributes : {
		vertex: null,
		fragment: null,
		texture: null,
	} ,

	// MATICE
	matrices : {
		model : {
			link: null,
			data: null,
		} ,
		view : {
			link: null,
			data: null,
		} ,
		projection : {
			link: null,
			data: null,
		} ,
	} ,


	texture: null,
	sampler: null,
	program: null,
	canvas: null,
};

//SETTINGS.input.video =  createVideo("data/R0010082.mp4"); // R0010014_20161217101030_er / R0010081
//SETTINGS.input.video =  createVideo("data/R0010082.mp4"); // R0010014_20161217101030_er / R0010081

SETTINGS.input.video =  createVideo("data/new/R0010083.mp4");

if (getParamByKey("video_src")) {
	SETTINGS.input.video =  createVideo("data/new/new2/"+getParamByKey("video_src")+".mp4");
}



 //SETTINGS.input.video = document.getElementById('video');
//SETTINGS.input.image = createImage("data/p7.jpg"); // p7.jpg / t1.jpg


// ovladaci prvky
createVideoControlls(document.querySelector("canvas").width/2,90, 0.0, 0.95,SETTINGS.input.video, 0 ) ;

function initProgram() {

	SETTINGS.mode.fisheye.panorama.active 			= false;
	SETTINGS.mode.fisheye.video.active 				= true;

	SETTINGS.mode.equirectangular.panorama.active 	= false;
	SETTINGS.mode.equirectangular.video.active 		= false;


	// nastaveni modu geometrie
	var fisheye_or_equi_mode = null;
	if (SETTINGS.mode.equirectangular.panorama.active  || SETTINGS.mode.equirectangular.video.active) {
		fisheye_or_equi_mode = 0;
	}
	else if (SETTINGS.mode.fisheye.panorama.active || SETTINGS.mode.fisheye.video.active ) {
		fisheye_or_equi_mode = 1;
	}
 

	// init webgl
	PROG.canvas = document.querySelector("canvas");
	gl =  PROG.canvas.getContext("webgl") || PROG.canvas.getContext("experimental-webgl");
	if (!gl) {
		w('Webgl se nepodarilo inicializovat...');
		return false;
	}

	// kontrola vstupnic dat
	if ((SETTINGS.mode.equirectangular.video.active || SETTINGS.mode.fisheye.video.active) && !SETTINGS.input.video) {
		e('video se nepdarilo nacist!');
		return false;
	}
	
	if ((SETTINGS.mode.equirectangular.panorama.active || SETTINGS.mode.fisheye.panorama.active) && !SETTINGS.input.image) {
		e('panorama se nepdarilo nacist!');
		return false;
	}


	// nastaveni vychozich data platna
	SETTINGS.default.canvas.width = PROG.canvas.width;
	SETTINGS.default.canvas.height = PROG.canvas.height;


	// vypocet geometrie
	GEOMETRY = createSphereGeometry(
		SETTINGS.mode.fisheye.video.latitudes, 
		SETTINGS.mode.fisheye.video.longtitudes, 
		SETTINGS.mode.fisheye.video.radius, 
		fisheye_or_equi_mode
	);

	// incializace matic
	PROG.matrices.model.data = createIdentityMatrix4();
	PROG.matrices.view.data = createIdentityMatrix4();
	PROG.matrices.projection.data = createIdentityMatrix4();

	return true;
}

function setupProgram() 
{
	if (!initProgram()) {
		e('FATALNI CHYBA, nepodarilo se inicializovat program');
		return false;
	}

	PROG.canvas.addEventListener( 'mousemove', onDocumentMouseMove, false );
	PROG.canvas.addEventListener( 'mousedown', onDocumentMouseDown, false );
	PROG.canvas.addEventListener("mouseout", onDocumentMouseOut, false);

	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
	document.addEventListener("keypress", onDocumentKeyPress, false);
	document.addEventListener("mousewheel", onDocumentMouseWheel, false);
	window.addEventListener('resize', onWindowResize, true);

	SETTINGS.input.video.addEventListener("timeupdate", function() {
 
 		var value = (100 / SETTINGS.input.video.duration) * SETTINGS.input.video.currentTime;
 		 var slider = document.getElementById(video_controlls_btn_slider_video);
 		slider.value = value;

 	});

	// nacitani videa
	SETTINGS.input.video.addEventListener('progress', function() {
	    var range = 0;
	    var buffered = SETTINGS.input.video.buffered;
	    var time = this.currentTime;
	});



	// nacteni, zkompilovani a overeni vertext shaderu
	var str = document.querySelector("#vs").textContent;
	var vs = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vs, str);
	gl.compileShader(vs);
	var vertextSucces = gl.getShaderParameter(vs, gl.COMPILE_STATUS);
	if (!vertextSucces) {
		w('nepodařilo se zkompilovat VERTEX_SHADER');
		return false;
	}
	
	// nacteni, zkompilovani a overeni fragment shaderu
	var str = document.querySelector("#fs").textContent;
	var fs = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fs, str);
	gl.compileShader(fs);
	var fragmentSucces = gl.getShaderParameter(fs, gl.COMPILE_STATUS);
	if (!fragmentSucces) {
		w('nepodařilo se zkompilovat FRAGMENT_SHADER');
		return false;
	}

	// vytvoreni programu, pridani vertex a fragment shaderu a overeni
	PROG.program = gl.createProgram();
	gl.attachShader(PROG.program, vs);
	gl.attachShader(PROG.program, fs);
	gl.linkProgram(PROG.program);
	gl.useProgram(PROG.program);
	var programSuccess = gl.getProgramParameter( PROG.program, gl.LINK_STATUS);
	if ( ! programSuccess) {
	  var info = gl.getProgramInfoLog(PROG.program);
	  w ('nepodařilo se zkompilovat WebGL PROG. \n\n' + info);
	  return false;
	}
	
	// -------- ZOBRAZOVACI matice
	// MODEL matrix

	scale(PROG.matrices.model.data, 1.0, 1.0, 1.0);
	translate(PROG.matrices.model.data, 0.0, 0.0, 0.0);

	// ---- otoceni kamery do pocatecni pozice
	// PRO equirectangular
	if (SETTINGS.mode.equirectangular.panorama.active) {
		rotateZ(PROG.matrices.model.data,   Math.PI/2);
		rotateX(PROG.matrices.model.data,   Math.PI/2 );
		rotateY(PROG.matrices.model.data,   Math.PI/2 );
	}
	else if (SETTINGS.mode.equirectangular.video.active) {
		rotateZ(PROG.matrices.model.data,   Math.PI/2);
		rotateX(PROG.matrices.model.data,   3/2*Math.PI);
		rotateY(PROG.matrices.model.data,   Math.PI/2 );
	}
	// PRO fisheye
	else if (SETTINGS.mode.fisheye.panorama.active || SETTINGS.mode.fisheye.video.active){
		rotateZ(PROG.matrices.model.data,   Math.PI/2);
		rotateX(PROG.matrices.model.data,   2*Math.PI );
		rotateY(PROG.matrices.model.data,   2*Math.PI );
	}



	// DEBUG===========================================
	if (getParamByKey("angleX")) {
		rotateX(PROG.matrices.model.data,    Math.PI * getParamByKey("angleX") );
	}

	if (getParamByKey("angleZ")) {
		rotateZ(PROG.matrices.model.data,    Math.PI * getParamByKey("angleZ") );
	}

	if (getParamByKey("angleY")) {
		rotateY(PROG.matrices.model.data,    Math.PI * getParamByKey("angleY") );
	}

	// VIEW matrix
	if (getParamByKey("camera")) {
		translate(PROG.matrices.model.data,  0, 0, getParamByKey("camera"));
	}
	// DEBUG===========================================, konec


	// perspektivni matice
	// zorny uhel je 90%, pomer je jasnej
	PROG.matrices.projection.data = createPerspectiveMatrix(Math.PI/2.0, PROG.canvas.width/PROG.canvas.height, 0.1, 100);

	// ------ nahrani matic do promennych ==============================================================
	PROG.matrices.model.link = gl.getUniformLocation(PROG.program, "M_Matrix");
	gl.uniformMatrix4fv(PROG.matrices.model.link, false, PROG.matrices.model.data);

	PROG.matrices.view.link = gl.getUniformLocation(PROG.program, "V_Matrix");
	gl.uniformMatrix4fv(PROG.matrices.view.link, false, PROG.matrices.model.data);

	PROG.matrices.projection.link = gl.getUniformLocation(PROG.program, "P_Matrix");
	gl.uniformMatrix4fv(PROG.matrices.projection.link, false, PROG.matrices.projection.data);


	// sampler
	PROG.sampler = gl.getUniformLocation(PROG.program, "sampler");
	gl.uniform1i(PROG.sampler, 0);


	// -------- atributy
	PROG.attributes.vertex = gl.getAttribLocation(PROG.program, "pos");
	if (PROG.attributes.vertex===-1) w('Nebyl nalezen atribut "pos" ve vertex shaderu');
	gl.enableVertexAttribArray(PROG.attributes.vertex);

	PROG.attributes.fragment = gl.getAttribLocation(PROG.program, "fragPos");
	if (PROG.attributes.fragment==-1) w('Nebyl nalezen atribut "fragPos" ve vertex shaderu');
	gl.enableVertexAttribArray(PROG.attributes.fragment);

	PROG.attributes.texture = gl.getAttribLocation(PROG.program, "texture");
	if (PROG.attributes.texture==-1) w('Nebyl nalezen atribut "texture" ve vertex shaderu');
	gl.enableVertexAttribArray(PROG.attributes.texture);


	// -------- BUFFERY
	PROG.buffer.vertex = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.vertex);
	gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.vertices), gl.STATIC_DRAW);
	gl.vertexAttribPointer(PROG.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
	
	PROG.buffer.normal = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.normal);
	gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.normals), gl.STATIC_DRAW);
	gl.vertexAttribPointer(PROG.attributes.fragment, 3, gl.FLOAT, false, 0, 0);

	PROG.buffer.texture = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.texture);
	gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.textures), gl.STATIC_DRAW);
	gl.vertexAttribPointer(PROG.attributes.texture, 2, gl.FLOAT, false, 0, 0);

	PROG.buffer.index = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (GEOMETRY.indices), gl.STATIC_DRAW);

	// ---- NASTAVENI
	//gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.DEPTH_TEST);
	//gl.clearColor(0, 0, 0, 1);

	 //gl.enable(gl.BLEND);
	//gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


	// ----- VYTVORENI TEXTURY
	PROG.texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, PROG.texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.bindTexture(gl.TEXTURE_2D, null);


	// mapovani OBRAZKU =======================================
	// MUSI BYT TADY, protoze textura se narozdil od videa neaktualizuje
	// equirectangular
	if (SETTINGS.mode.equirectangular.panorama.active || SETTINGS.mode.fisheye.panorama.active) 
	{
		createLoader(150, 150, 0.5, 0.5, 1, 1258) ;
		if (imgLoaded){
			createLoader(150, 150, 0.5, 0.5, 0, 1258) ;
			gl.bindTexture(gl.TEXTURE_2D, PROG.texture);
			if (SETTINGS.mode.equirectangular.panorama.active) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			}
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, SETTINGS.input.image);
		}
		else {
			w('obrazek se nepodarilo uspesne nacist');
			return false;
		}
	}

	return true;
}

// aktualizace textury v pripade videa
function updateTexture() 
{
	if (SETTINGS.mode.fisheye.video.active || SETTINGS.mode.equirectangular.video.active) 
	{
		if (SETTINGS.input.video.readyState >= SETTINGS.input.video.HAVE_CURRENT_DATA) 
		{
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, PROG.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,gl.UNSIGNED_BYTE, SETTINGS.input.video);
			gl.bindTexture(gl.TEXTURE_2D, null);
			createLoader(150, 150, 0.5, 0.5, 0, 1258) ;
			return true;
		}

		if (SETTINGS.input.video.readyState < SETTINGS.input.video.HAVE_CURRENT_DATA) 
		{
			console.log('video se nacita...');
			createLoader(150, 150, 0.5, 0.5, 1, 1258) ;
			return false;

		}
	}

	return true;
}


function initViewMatrix() {
	
	/// ROTACNI MATICE pomoci MYSI
	var atr = 0;
	makeIdentityFrom(PROG.matrices.view.data );
	translate(PROG.matrices.view.data,0, 0, atr);
}

function updateCameraPosition() {
	/// ROTACe MATICE pomoci MYSi a klavesnice
	translate(PROG.matrices.view.data,0, 0, MOUSE.wheel.delta);
	rotateY( PROG.matrices.view.data, MOUSE.move.angle.y);
	rotateX( PROG.matrices.view.data, MOUSE.move.angle.x);
	
}

function getCameraPosition() {
	return PROG.matrices.view.data[14];
}

function render() {

	// METADATa PRO VIDEO VIDEO
	// status bar a cas
	if (SETTINGS.mode.fisheye.video.active  || SETTINGS.mode.equirectangular.video.active) {
		var elem = document.getElementById("data").innerHTML = 'Čas: '+SETTINGS.input.video.currentTime;
		createVideoStatusBar(170, 30, 0.8, 1, SETTINGS.input.video);


	}
		
	// zorny uhel
	//createFieldVision(150,150,0.4,1, -parseInt(160-MOUSE.wheel.delta *80), 0.0/*MOUSE.move.angle.y*57*/); 
	var angle =  radToDeg(Math.PI/2)  -(MOUSE.wheel.delta/MOUSE.wheel.deltaMax*65);
	var shift = (MOUSE.move.angle.y * (180/Math.PI))%360 ;
	createFieldVision(150,150,0.4,1, (angle ? angle : 10), 0); 

	// kompas
	var north = 315; // umisteni severu v kompasu
	SETTINGS.compass.north = 315;
	SETTINGS.compass.angle = shift;
	 createCompass(180,180, 0.6, 0.95, SETTINGS.compass.north, SETTINGS.compass.angle) ;


	// aktualizace textury
	if (updateTexture()) 
	{
		// inicializace zobrazovaci matice
		initViewMatrix();

			// zmena pozice zobrazeni
		updateCameraPosition();

		// nahrani matic do programu
		gl.uniformMatrix4fv(PROG.matrices.projection.link, false, PROG.matrices.projection.data);
		gl.uniformMatrix4fv(PROG.matrices.view.link, false, PROG.matrices.view.data);
		gl.uniformMatrix4fv(PROG.matrices.model.link, false, PROG.matrices.model.data);


		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, PROG.texture);
		gl.uniform1i(PROG.sampler, 0);

		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);

		// zde prepinanim renderovani
		if (!GEOMETRY.noIndices) {
			// renderuje se equirectangularni zobrazeni, takze muzu pouzit indexy
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);
			gl.drawElements(gl.TRIANGLES, GEOMETRY.indices.length, gl.UNSIGNED_SHORT, 0);
		}
		else {

			gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.vertex);
			gl.drawArrays(gl.TRIANGLES,0, GEOMETRY.normals.length/3);
		}
	}
	requestAnimationFrame(render);
}

window.requestAnimationFrame = window.requestAnimationFrame 
	|| window.mozRequestAnimationFrame
	|| window.webkitRequestAnimationFrame
	|| function(cb) { setTimeout(cb, 1000/60); };



function onDocumentMouseWheel( event ) {
	var newDelta = 0;
	if (event.wheelDeltaY) {
		// WebKit
		newDelta +=event.wheelDeltaY;
		}
		else if (event.wheelDelta) {
		// Opera / Explorer 9
		newDelta += event.wheelDelta;
		}
		else if (event.detail) {
		// Firefox
			newDelta  += event.detail;
		}

		// zmenseni maximalniho priblizeni
		var reduction = (MOUSE.wheel.reduction > 1.0) ? MOUSE.wheel.reduction : 1.0;

		// meze kolecka
		MOUSE.wheel.deltaMax = (SETTINGS.mode.fisheye.video.radius-2*MOUSE.wheel.sensitivity)/reduction;
		MOUSE.wheel.deltaMin = -MOUSE.wheel.deltaMax;

		// osetreni mezi kolecka
		if (Math.abs(MOUSE.wheel.delta) < MOUSE.wheel.deltaMax) 
		{
			if (newDelta>0) 
			{ 	
				// je pozitivni

				MOUSE.wheel.delta+=MOUSE.wheel.sensitivity;
			}
			else {
				MOUSE.wheel.delta-=MOUSE.wheel.sensitivity;
			}
		}
		else {
			if (MOUSE.wheel.delta>0) {
				MOUSE.wheel.delta-=MOUSE.wheel.sensitivity;
			}
			else {
				MOUSE.wheel.delta+=MOUSE.wheel.sensitivity;
			}
		}
}


// osetreni mysi a metadat
// v pripade ze mys najede na nejaky html prvek, protoze je platno prekryto, bude sestale snimat mys -> problem nastane v momente kdy mysi pri tahu vyjedeme z canvasu
// nedojde tak k preruseni funkce mysi a po navratu do canvasu staůe funguje snimani a nacitani mysi, coz pusobi rusive
function onDocumentMouseOut( event ) {
	if (MOUSE.active && !MOUSE.interrupt) {
		MOUSE.active = false;
	}
}


function onDocumentMouseUp( event ) {
	MOUSE.active = false;
}


function onDocumentMouseDown( event ) {
	MOUSE.active = true;
	MOUSE.down.x = event.pageX;
	MOUSE.down.y = event.pageY;
	event.preventDefault();
	return false;
}

function onDocumentMouseMove( event ) {
	if (MOUSE.active && !MOUSE.interrupt) 
	{
 		// zastavi mys pred vyjetim z canvasu
		if (event.pageX >= (PROG.canvas.width-10) || event.pageY >= (PROG.canvas.height-10)) {
			MOUSE.active = false;
			return false;
		}
 
		MOUSE.move.x = (event.pageX - MOUSE.down.x)*2*Math.PI/PROG.canvas.width,
		MOUSE.move.y = (event.pageY - MOUSE.down.y)*2*Math.PI/PROG.canvas.height;
		MOUSE.move.angle.y+= MOUSE.move.x;
		MOUSE.move.angle.x+=MOUSE.move.y;
		MOUSE.down.x = event.pageX; 
		MOUSE.down.y = event.pageY;
		event.preventDefault();
	}
}


function onDocumentKeyPress( event ) {
	if (KEYBOARD.active) 
	{
		if (event.keyCode == 113 || event.keyCode == 81) { // q/Q
			vide_playing = 1;
			SETTINGS.input.video.play();
		}

		if (event.keyCode == 101 || event.keyCode == 69) { // e/E
			SETTINGS.input.video.pause();
			vide_playing = 0;
		}

		// start/stop pomoci mezerniku
		if (event.keyCode === 0 || event.keyCode === 32) {
			if (!vide_playing ) {
				SETTINGS.input.video.play();
				vide_playing = 1;
			}	
			else if (vide_playing ) {
				SETTINGS.input.video.pause();
				vide_playing = 0;
			}
		}


		if (event.keyCode == 97  ||  event.keyCode==97-32 ) { // a/A
			MOUSE.move.angle.y += KEYBOARD.sensitivity.x;
		}
		else if (event.keyCode == 100    ||  event.keyCode==100-32) {  // d/D
			MOUSE.move.angle.y -= KEYBOARD.sensitivity.x;
		}

		else if (event.keyCode == 119 ||   event.keyCode == 119-32 ) {  // w/W
			MOUSE.move.angle.x -=  KEYBOARD.sensitivity.y;

		}
		else if (event.keyCode == 115 ||    event.keyCode == 115-32) {  //	s/S
			MOUSE.move.angle.x +=  KEYBOARD.sensitivity.y;
		}
	}
}

function onWindowResize( event ) {

	var element_canvas = document.querySelector("canvas");
	if (element_canvas ) { // blocked
		element_canvas.width = window.innerWidth;
		element_canvas.height = window.innerHeight;
		gl.viewport(0, 0, element_canvas.width, element_canvas.height);
  		setupProgram() ;
	}
}

function resize() {
	createVideoStatusBar(170, 30, 0.8, 1, SETTINGS.input.video);
	createFieldVision(150,150,0.4,1, (SETTINGS.compass.angle ? SETTINGS.compass.angle : 10), 0);
	createCompass(180,180, 0.6, 0.95, SETTINGS.compass.north, SETTINGS.compass.angle) ;
	createVideoStatusBar(170, 30, 0.8, 1, SETTINGS.input.video);

	createVideoControlls(PROG.canvas.width/2,90, 0.0, 0.9, SETTINGS.input.video, 1 ) ;
}

function main() 
{
	if (!SETTINGS.input.video)  return false;

	if (!initProgram()) {
		return false;
	}

	if (!setupProgram()) {
		return false;
	}

	render();
 

/*
SETTINGS.input.video.oncanplaythrough = function() {
	render();
	//video.play();
};
*/


/*
	video.addEventListener("timeupdate", function(){
		if(this.currentTime >= 8){
			this.pause();
		}
	});
*/

	 
	SETTINGS.input.video.addEventListener("loadedmetadata",function() { 
		this.currentTime = (getParamByKey("time") ? getParamByKey("time") : 8.4) ;
	},false);




}


</script>

</html>
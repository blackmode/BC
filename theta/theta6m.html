<!DOCTYPE html>
<html lang="en">
	<head>
		<title>BC - panorama viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		 <script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
		 <script type="text/javascript" src="../src/js/lib.js"></script>
		 <script type="text/javascript" src="../src/js/Externallib.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	</head>

	<style type="text/css">
		body {
			margin: 0px;
			padding: 0px;
			border: 0px solid blue;
			width: auto;
			height: auto;
		}
		 .unique:before {
		   content: attr(data-label);
		}

		progress {
	  		display: block;
			/* Important Thing */
			-webkit-appearance: none !Important;
	 		border: none;
		}

	</style>

	<script id="vs" type="x-shader/x-vertex">
		attribute vec3 pos;
		attribute vec2 texture;

		uniform mat4 MMatrix;
		uniform mat4 VMatrix;
		uniform mat4 PMatrix;

		varying vec2 varyingTexture;

		attribute vec3 fragPos;
		varying vec3 varyingFragPosNormal;
			
		void main(void) {
			gl_Position = PMatrix * VMatrix * MMatrix * vec4(pos, 1.0);
			varyingTexture = texture;
			varyingFragPosNormal = fragPos;// musim predat normaly, abych nemusel predavati radius
 

		}
	</script>

	<script id="fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec3 varyingFragPosNormal;
		varying vec2 varyingTexture;
		uniform sampler2D sampler;  
		#define PI 3.14159265359
		#define KERNEL_LENGTH 30

		float offset[KERNEL_LENGTH];
		float weight[KERNEL_LENGTH];


		// clamp(u,v) => vraci stredni hodnotu mezi dvema vstupnimi hodnotami 

		void main(void) {
			 gl_FragColor = texture2D(sampler, varyingTexture);

 /*

             if (
             	varyingTexture.x  >0.12 &&
             	varyingTexture.x  <0.37 && 
             	varyingTexture.y >0.30	&& 
             	varyingTexture.y <0.57  
             	); else if (varyingTexture.x <0.5){
 				gl_FragColor.r =  (gl_FragColor.r * 0.1) ;
 				gl_FragColor.g =  (gl_FragColor.g * 0.1) ;
 				gl_FragColor.b =  (gl_FragColor.b * 0.1) ;
             }
*/

//(( (1.0/cos( z2 )) / sqrt( x2 * x2 + y2 * y2 ) ) * ( 2.0 / 3.14159265359 ))

            float x2=varyingFragPosNormal.x ;
            float y2=varyingFragPosNormal.y  ;
            float z2=varyingFragPosNormal.z  ;
  

            // souradnice stredu
            float Sx = 0.0;
            float Sy = 0.0;

            float a = abs(Sx - x2);
            float b = abs(Sy - y2);
            float c = sqrt(a*a + b*b) ;
            // DEBUG===========================================



            if (c > 0.998       ) { 	// JE TAM DANA "&&c==0.0" ABY TO NEBYLO PLATNY! PAK ODDELAT!
 				/*
 				gl_FragColor.r =  (gl_FragColor.r * 0.1) ;
 				gl_FragColor.g =  (gl_FragColor.g * 0.1) ;
 				gl_FragColor.b =  (gl_FragColor.b * 0.1) ;
 				*/
 				//gl_FragColor = texture2D(sampler, vec2(varyingTexture)/1024.0) * 0.2270270270;
 				offset[0] =  0.0;
 				offset[1] =  1.0;
 				offset[2] =  2.0;
 				offset[3] =  3.0;
 				offset[4] =  4.0;

 				weight[0] =  0.2270270270;
 				weight[1] =  0.1945945946;
 				weight[2] =  0.1216216216;
 				weight[3] =   0.0540540541;
 				weight[4] =   0.0162162162;

				for (int i=1; i<5; i++) {
 
					//gl_FragColor+= texture2D(sampler, (vec2(varyingTexture)+vec2(0.0,offset[i]))/1024.0) * weight[i];
					//gl_FragColor+= texture2D(sampler, (vec2(varyingTexture)-vec2(0.0,offset[i]))/1024.0) * weight[i];
 
				}


 				 //gl_FragColor.a =   0.6;
            }


			// korekce barvy
			if (varyingTexture.x< 0.5      ) {
				// gl_FragColor.a =   0.988;
 			}
			//gl_FragColor = vec4(1.0, 0.4, 1.0, 1.0);
		}
	</script>



	<body onload="main()" id="body">
	<!--
 	  <video preload="auto" id="video" loop="false" webkit-playsinline crossOrigin="anonymous" style="    width: 800px; height: 600px " controls muted autoplay>
		 <source src="data/firefox.ogv" type="video/mp4"> 
		<source src="data/theta2.mp4" type="video/mp4">
	  </video> -->




		<div id="viewer" style="position:relative ">
			<canvas id="glcanvas" width="800" height="600"></canvas>
			<div id="compass-box"></div>
			<div id="field_vision">
				<svg>
					<path id="svg_path"></path>
				</svg>
			</div>
			<div id="video_status_bar"></div>
			<div id="overlay"></div>
		</div>
		<div id="data"></div>
	</body>


 

<script>


//var video = createVideo("data/theta2.mp4");
//var video = createVideo("data/R0010079.mp4");

//createCompass(200,200, 0.6, 1) ;
 


var gl;
var GEOMETRY;
var vide_playing = 0;
var video = createVideo("data/R0010081.mp4"); 


/// ------ VSECHNY PROMENNE PRO MYS
var MOUSE = {
	down : {
		x: 0.0,
		y: 0.0,
	} ,
	move : {
		x: 0.0,
		y: 0.0,
		angle: {
			x: 0.0,
			y: 0.0,
		} ,
	} ,
	wheel : {
		sensitivity: 1.5/10,
		reduction: 1.3, // radius/4
		delta: 0.0,
	} ,

 	active : false,
};


/// ------ VSECHNY PROMENNE PRO KLAVESNICI
var KEYBOARD = {
	active : true,
	sensitivity : {
		x: 0.06,
		y:  0.06,
	} ,
};


/// ------ VSECHNY nastaveni PROGRAMU
var SETTINGS = {
	mode : {
		equirectangular : {
			panorama: null,
			video: null,
		} ,
		fisheye : {
			panorama: null,
			video : {
				active: true,
				latitudes: 60,
				longtitudes: 60,
				radius: 7,
			} ,
		} ,	
	},
	field_vision : {
		wdith: 0.06,
		height:  0.06,
		canvas_position_x:  0.06,
		canvas_position_y:  0.06,
	} ,
	compass : {
		wdith: 0.06,
		height:  0.06,
		canvas_position_x:  0.06,
		canvas_position_y:  0.06,
	} ,
};

/// ------ VSECHNY promenne PROGRAMU
var PROG = {

	shader : {
		equirectangular : {
			panorama: null,
			video: null,
		} ,
	},

	buffer : {
		normal: null,
		index: null,
		vertex: null,
		texture: null,
	} ,

	attributes : {
		vertex: null,
		fragment: null,
		texture: null,
	} ,

	
	matrices : {
		model : {
			link: null,
			data: null,
		} ,
		view : {
			link: null,
			data: null,
		} ,
		projection : {
			link: null,
			data: null,
		} ,
	} ,


	texture: null,
	sampler: null,
	gl: null,
	program: null,
	canvas: null,
};

 


	function initProgram() {

		GEOMETRY = createSphereGeometry(60,60,7,1) ;
		PROG.matrices.model.data = createIdentityMatrix4();
		PROG.matrices.view.data = createIdentityMatrix4();
		PROG.matrices.projection.data = createIdentityMatrix4();

 		PROG.canvas = document.querySelector("canvas");

		gl =  PROG.canvas.getContext("webgl") || PROG.canvas.getContext("experimental-webgl");
		if (!gl) {
			w('Webgl se nepodarilo inicializovat...');
		}

		return true;
	}

	function setupProgram() {
			if (!initProgram()) {
				e('FATALNI CHYBA, nepodarilo se inicializovat program');
				return false;
			}

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener("keypress", onDocumentKeyPress, false);
			document.addEventListener("mousewheel", onDocumentMouseWheel, false);
			window.addEventListener('resize', onWindowResize, true);

			// nacteni, zkompilovani a overeni vertext shaderu
			var str = document.querySelector("#vs").textContent;
			var vs = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vs, str);
			gl.compileShader(vs);
			var vertextSucces = gl.getShaderParameter(vs, gl.COMPILE_STATUS);
			if (!vertextSucces) {
				w('nepodařilo se zkompilovat VERTEX_SHADER');
				return false;
			}
			
			// nacteni, zkompilovani a overeni fragment shaderu
			var str = document.querySelector("#fs").textContent;
			var fs = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fs, str);
			gl.compileShader(fs);
			var fragmentSucces = gl.getShaderParameter(fs, gl.COMPILE_STATUS);
			if (!fragmentSucces) {
				w('nepodařilo se zkompilovat FRAGMENT_SHADER');
				return false;
			}

			// vytvoreni programu, pridani vertex a fragment shaderu a overeni
			PROG.program = gl.createProgram();
			gl.attachShader(PROG.program, vs);
			gl.attachShader(PROG.program, fs);
			gl.linkProgram(PROG.program);
			gl.useProgram(PROG.program);
			var programSuccess = gl.getProgramParameter( PROG.program, gl.LINK_STATUS);
			if ( ! programSuccess) {
			  var info = gl.getProgramInfoLog(PROG.program);
			  w ('nepodařilo se zkompilovat WebGL PROG. \n\n' + info);
			  return false;
			}
			
			// -------- ZOBRAZOVACI matice
			// MODEL matrix

			scale(PROG.matrices.model.data, 1.0, 1.0, 1.0);
			translate(PROG.matrices.model.data, 0.0, 0.0, 0.0);

			// ---- otoceni kamery do pocatecni pozice
			rotateZ(PROG.matrices.model.data,   Math.PI/2);
			rotateX(PROG.matrices.model.data,   2*Math.PI );
			rotateY(PROG.matrices.model.data,   2*Math.PI );


			// DEBUG===========================================
			if (getParamByKey("angleX")) {
				rotateX(PROG.matrices.model.data,    Math.PI * getParamByKey("angleX") );
			}

			if (getParamByKey("angleZ")) {
				rotateZ(PROG.matrices.model.data,    Math.PI * getParamByKey("angleZ") );
			}

			if (getParamByKey("angleY")) {
				rotateY(PROG.matrices.model.data,    Math.PI * getParamByKey("angleY") );
			}

			// VIEW matrix
			if (getParamByKey("camera")) {
				mat4.translate(PROG.matrices.model.data, PROG.matrices.model.data, vec3.fromValues(0, 0, getParamByKey("camera") ));
			}
			// DEBUG===========================================, konec


			// perspektivni matice
			// zorny uhel je 90%, pomer je jasnej
			PROG.matrices.projection.data = createPerspectiveMatrix(Math.PI/2, PROG.canvas.width/PROG.canvas.height, 0.1, 100);

			// ------ nahrani matic do promennych ==============================================================
 			PROG.matrices.model.link = gl.getUniformLocation(PROG.program, "MMatrix");
			gl.uniformMatrix4fv(PROG.matrices.model.link, false, PROG.matrices.model.data);

			PROG.matrices.view.link = gl.getUniformLocation(PROG.program, "VMatrix");
			gl.uniformMatrix4fv(PROG.matrices.view.link, false, PROG.matrices.model.data);
		
			PROG.matrices.projection.link = gl.getUniformLocation(PROG.program, "PMatrix");
			gl.uniformMatrix4fv(PROG.matrices.projection.link, false, PROG.matrices.projection.data);


			// sampler
			PROG.sampler = gl.getUniformLocation(PROG.program, "sampler");
			gl.uniform1i(PROG.sampler, 0);


			// -------- atributy
			PROG.attributes.vertex = gl.getAttribLocation(PROG.program, "pos");
			if (PROG.attributes.vertex===-1) w('Nebyl nalezen atribut "pos" ve vertex shaderu');
			gl.enableVertexAttribArray(PROG.attributes.vertex);

			PROG.attributes.fragment = gl.getAttribLocation(PROG.program, "fragPos");
			if (PROG.attributes.fragment==-1) w('Nebyl nalezen atribut "fragPos" ve vertex shaderu');
			gl.enableVertexAttribArray(PROG.attributes.fragment);

			PROG.attributes.texture = gl.getAttribLocation(PROG.program, "texture");
			if (PROG.attributes.texture==-1) w('Nebyl nalezen atribut "texture" ve vertex shaderu');
			gl.enableVertexAttribArray(PROG.attributes.texture);


			// -------- BUFFERY
			PROG.buffer.vertex = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.vertex);
			gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.vertices), gl.STATIC_DRAW);
			gl.vertexAttribPointer(PROG.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
			
			PROG.buffer.normal = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.normal);
			gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.normals), gl.STATIC_DRAW);
			gl.vertexAttribPointer(PROG.attributes.fragment, 3, gl.FLOAT, false, 0, 0);

			PROG.buffer.texture = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.texture);
			gl.bufferData(gl.ARRAY_BUFFER, (GEOMETRY.textures), gl.STATIC_DRAW);
			gl.vertexAttribPointer(PROG.attributes.texture, 2, gl.FLOAT, false, 0, 0);

			PROG.buffer.index = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (GEOMETRY.indices), gl.STATIC_DRAW);

			// ---- NASTAVENI
			//gl.disable(gl.DEPTH_TEST);
			gl.enable(gl.DEPTH_TEST);
			//gl.clearColor(0, 0, 0, 1);

			 //gl.enable(gl.BLEND);
			//gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


			// ----- VYTVORENI TEXTURY
			texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

			gl.bindTexture(gl.TEXTURE_2D, null);
	}

 
	function updateTexture() {
		if (SETTINGS.mode.fisheye.video.active) 
		{
		  if (video.readyState >= video.HAVE_CURRENT_DATA) 
		  {
			  gl.activeTexture(gl.TEXTURE0);
			  gl.bindTexture(gl.TEXTURE_2D, texture);
			  //gl.pixelStorei(gl.UNPACK_FLIP_X_WEBGL, true);
			  // the next line fails in Safari if the video is coming from another domain or subdomain
			  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,gl.UNSIGNED_BYTE, video);
			  gl.bindTexture(gl.TEXTURE_2D, null);
			  document.getElementById('overlay').style.display = 'none';
			  return true;
		  }

		  if (video.readyState < video.HAVE_CURRENT_DATA) {

				console.log('video se nacita...');
				// neexistoval, tak jej vytvorim
				var status_bar_width = 150;
				var status_bar_height = 150;
				var canvas_dom = document.getElementsByTagName("canvas")[0];
				// dynamicke umisteni zadane parametrem
				var left_correction = (150/canvas_dom.width); 
				var status_bar_left =  canvas_dom.width*((0.55)-left_correction);

				var top_correction = (150/canvas_dom.height); 
				var status_bar_top =   canvas_dom.height*((0.55)-top_correction);

				// stylovani prvku
				var div = document.getElementById('overlay');
				div.style.width = status_bar_width+'px';
				div.style.height = status_bar_height+'px';
				div.style.left = status_bar_left+'px';
				div.style.top = status_bar_top+'px';
				div.style.backgroundColor  = 'transparent';
				div.style.background  = 'url(../src/img/loading.gif)';
				div.style.opacity  = 1;
				div.style.position = 'absolute';
				div.style.overflow = 'hidden';
				div.style.padding = '5px';

				return false;

		  }

		}
	}

 
		 function initViewMatrix() {
			/// ROTACNI MATICE pomoci MYSI
			var atr = 0;
			makeIdentityFrom(PROG.matrices.view.data );
			translate(PROG.matrices.view.data,0, 0, atr);

 		 }

		function updateCameraPosition() {
			/// ROTACe MATICE pomoci MYSi a klavesnice
			translate(PROG.matrices.view.data,0, 0, MOUSE.wheel.delta);
			rotateY( PROG.matrices.view.data, MOUSE.move.angle.y);
			rotateX( PROG.matrices.view.data, MOUSE.move.angle.x);
		}

		function getCameraPosition() {
			return PROG.matrices.view.data[14];
		}

		function render() {
			// status bar a cas
			var elem = document.getElementById("data").innerHTML = 'Čas: '+video.currentTime;
			createVideoStatusBar(170, 30, 0.8, 1, video);
 			
 			// zorny uhel
			var koef = (Math.abs(MOUSE.move.angle.y)/2*Math.PI)%2;
			//createFieldVision(150,150,0.4,1, -parseInt(160-MOUSE.wheel.delta *80), 0.0/*MOUSE.move.angle.y*57*/); 
			createFieldVision(150,150,0.4,1, 30, MOUSE.move.angle.y * (180/Math.PI) ); 
			// aktualizace textury
			if (updateTexture()) 
			{
				// inicializace zobrazovaci matice
				initViewMatrix();
	 
	 			// zmena pozice zobrazeni
				updateCameraPosition();

				// nahrani matic do programu
				gl.uniformMatrix4fv(PROG.matrices.projection.link, false, PROG.matrices.projection.data);
				gl.uniformMatrix4fv(PROG.matrices.view.link, false, PROG.matrices.view.data);
				gl.uniformMatrix4fv(PROG.matrices.model.link, false, PROG.matrices.model.data);


				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.uniform1i(PROG.sampler, 0);

				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);

				// zde prepinanim renderovani
				if (!GEOMETRY.noIndices) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, PROG.buffer.index);
					gl.drawElements(gl.TRIANGLES, GEOMETRY.indices.length, gl.UNSIGNED_SHORT, 0);
				}
				else {

					gl.bindBuffer(gl.ARRAY_BUFFER, PROG.buffer.vertex);// HAZI TO VIC CHYB, nevim  jeste proc
					gl.drawArrays(gl.TRIANGLES,0, GEOMETRY.normals.length/3);
				}
			}
			requestAnimationFrame(render);
		}

		window.requestAnimationFrame = window.requestAnimationFrame 
			|| window.mozRequestAnimationFrame
			|| window.webkitRequestAnimationFrame
			|| function(cb) { setTimeout(cb, 1000/60); };



		function onDocumentMouseWheel( event ) {
			var newDelta = 0;
			if (event.wheelDeltaY) {
			    // WebKit
			    newDelta +=event.wheelDeltaY;
			    }
			    else if (event.wheelDelta) {
			    // Opera / Explorer 9
			    newDelta += event.wheelDelta;
			    }
			    else if (event.detail) {
			    // Firefox
			        newDelta  += event.detail;
			    }

			    // zmenseni maximalniho priblizeni
			    var reduction = (MOUSE.wheel.reduction > 1.0) ? MOUSE.wheel.reduction : 1.0;

			    if (Math.abs(MOUSE.wheel.delta) < (SETTINGS.mode.fisheye.video.radius-2*MOUSE.wheel.sensitivity)/reduction) 
			    {
			    	if (newDelta>0) 
			    	{ 	
			    		// je pozitivni

						MOUSE.wheel.delta+=MOUSE.wheel.sensitivity;
			    	}
			    	else {
			    		MOUSE.wheel.delta-=MOUSE.wheel.sensitivity;
			    	}
			    }
			    else {
			    	if (MOUSE.wheel.delta>0) {
			    		MOUSE.wheel.delta-=MOUSE.wheel.sensitivity;
			    	}
			    	else {
			    		MOUSE.wheel.delta+=MOUSE.wheel.sensitivity;
			    	}
			    }
			   d(getCameraPosition());
		}


		function onDocumentMouseUp( event ) {
			MOUSE.active = false;
		}
 
 
		function onDocumentMouseDown( event ) {
            MOUSE.active = true;
            MOUSE.down.x = event.pageX;
            MOUSE.down.y = event.pageY;
            event.preventDefault();
            return false;
		}

		function onDocumentMouseMove( event ) {
 
            if (MOUSE.active) {
	            MOUSE.move.x = (event.pageX - MOUSE.down.x)*2*Math.PI/PROG.canvas.width,
	            MOUSE.move.y = (event.pageY - MOUSE.down.y)*2*Math.PI/PROG.canvas.height;
	            MOUSE.move.angle.y+= MOUSE.move.x;
	            MOUSE.move.angle.x+=MOUSE.move.y;
	            MOUSE.down.x = event.pageX; 
	            MOUSE.down.y = event.pageY;
	            event.preventDefault();
      		}
		}


		function onDocumentKeyPress( event ) {
			if (KEYBOARD.active) 
			{

	 			if (event.keyCode == 113 || event.keyCode == 81) { // q/Q
	 				vide_playing = 1;
					video.play();
	 			}

				if (event.keyCode == 101 || event.keyCode == 69) { // e/E
					video.pause();
					vide_playing = 0;
				}
	 
				// start/stop pomoci mezerniku
				if (event.keyCode === 0 || event.keyCode === 32) {
					if (!vide_playing ) {
						video.play();
						vide_playing = 1;
					}	
					else if (vide_playing ) {
						video.pause();
						vide_playing = 0;
					}
				}


				if (event.keyCode == 97  ||  event.keyCode==97-32 ) { // a/A
					
					 MOUSE.move.angle.y += KEYBOARD.sensitivity.x;
	 			}
				else if (event.keyCode == 100    ||  event.keyCode==100-32) {  // d/D
 					 MOUSE.move.angle.y -= KEYBOARD.sensitivity.x;
	 			}
	  
				else if (event.keyCode == 119 ||   event.keyCode == 119-32 ) {  // w/W
 						 MOUSE.move.angle.x -=  KEYBOARD.sensitivity.y;
	 
				}
				else if (event.keyCode == 115 ||    event.keyCode == 115-32) {  //	s/S
 					 MOUSE.move.angle.x +=  KEYBOARD.sensitivity.y;
	 
				}
			}
		}

		function onWindowResize( event ) {

			var element_canvas = document.querySelector("canvas");
			if (element_canvas && 0) {
				element_canvas.width = window.innerWidth;
            	element_canvas.height = window.innerHeight;
			}
		}


		function main() {
			initProgram();
			setupProgram();
			render();


			 

			video.oncanplaythrough = function() {
				render();
				//video.play();
			};

			/*
			video.addEventListener("timeupdate", function(){
			    if(this.currentTime >= 8){
			        this.pause();
			    }
			});
			*/

			 
			video.addEventListener("loadedmetadata",function() { 
				this.currentTime = (getParamByKey("time") ? getParamByKey("time") : 8.4) ;
			 },false);
 



		}
 

	</script>



</html>

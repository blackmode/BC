         <script type="text/javascript" src="gl-matrix-2.2.1.js"></script>
         <script type="text/javascript" src="../src/js/lib.js"></script>
         <script type="text/javascript" src="../src/js/Externallib.js"></script>


<!-- Vertex shader program -->
<script id="shader-vs" type="x-shader/x-vertex">
 attribute vec2 texture;
 attribute vec2 aVertexPosition;
varying vec2 vDirection;
  
        uniform mat4 MMatrix;
        uniform mat4 VMatrix;
        uniform mat4 PMatrix;

void main(void) {
  gl_Position =   vec4(aVertexPosition, 1.0 ,1.0 );
  vDirection = texture;
}
</script>


<!-- Fragmend shader program -->
<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec2 vDirection;
uniform sampler2D uSampler;

void main(void) {
  //gl_FragColor = texture2D(uSampler,  vec2(vDirection.x*0.5+0.5, vDirection.y*0.5+0.5));
  gl_FragColor = texture2D(uSampler,   vDirection );
}
</script>

   <canvas id="glcanvas" style="width: 500px; height: 350px;"></canvas>
  <video muted preload="auto" id="video" loop="false" webkit-playsinline crossOrigin="anonymous" style="    width: 300px; height: 200px " controls style="width: 500px; height: 350px;">
     <source src="data/firefox.ogv" type="video/mp4"> 
    <!--<source src="data/R0010014_20161217101030_er.mp4" type="video/mp4">-->
  </video>
 

<script type="text/javascript">
// get DOM elements
videoContainer = document.getElementById('video-container');
video = document.getElementById('video');
canvas = document.getElementById('glcanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var mmatrix = mat4.create();
var vmatrix = mat4.create();
var pmatrix = mat4.create();
function create2DGeometry () 
{
  var vertices = [];
  var textures = [];
  var normals = [];
  var indices = [];

    // x,y,z
        var vertices = [
      -1.0, -1.0,
      1.0, -1.0,
      1.0,  1.0,
      -1.0,  1.0
        ];

    var textures = [
        0.0,  0.0,
        1.0,  0.0,
        1.0,  1.0,
        0.0,  1.0
    ];

    // x,y,z
        var normals = [

        ];

    var indices = [
      0,  1,  2,      0,  2,  3
    ];



  return {
    vertices: new Float32Array(vertices),
    textures: new Float32Array(textures),
    normals: new Float32Array(normals),
    indices: new Uint16Array(indices),
  };
}

var GEOMETRY = create2DGeometry( );
console.log(GEOMETRY);
var vertexPositionData = GEOMETRY.vertices;
var normalData = GEOMETRY.normals;
var textureCoordData =GEOMETRY.textures;
var indexData = GEOMETRY.indices;

// load the video, and play on ready
video.load();
video.oncanplaythrough = function() {
  video.play();
  drawScene();
};

gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

// create and attach the shader program to the webGL context
var attributes, uniforms, program;
var attachShader = function(params) {
  // compile the shaders from the shaders scripts
  var getShaderByName = function(id) {
    var shaderScript = document.getElementById(id);

    var theSource = "";
    var currentChild = shaderScript.firstChild;

    while(currentChild) {
      if (currentChild.nodeType === 3) {
        theSource += currentChild.textContent;
      }
      currentChild = currentChild.nextSibling;
    }

    var result;
    if (shaderScript.type === "x-shader/x-fragment") {
      result = gl.createShader(gl.FRAGMENT_SHADER);
    } else {
      result = gl.createShader(gl.VERTEX_SHADER);
    }
    gl.shaderSource(result, theSource);
    gl.compileShader(result);

    if (!gl.getShaderParameter(result, gl.COMPILE_STATUS)) {
      alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(result));
      return null;
    }
    return result;
  };

  fragmentShader = getShaderByName(params.fragmentShaderName);
  vertexShader = getShaderByName(params.vertexShaderName);

  program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  // get the location of attributes and uniforms
  attributes = {};
  for (var i = 0; i < params.attributes.length; i++) {
    var attributeName = params.attributes[i];
    attributes[attributeName] = gl.getAttribLocation(program, attributeName);
    gl.enableVertexAttribArray(attributes[attributeName]);
  }
  uniforms = {};
  for (i = 0; i < params.uniforms.length; i++) {
    var uniformName = params.uniforms[i];
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
    gl.enableVertexAttribArray(attributes[uniformName]);
  }
};
attachShader({
  fragmentShaderName: 'shader-fs',
  vertexShaderName: 'shader-vs',
  attributes: ['aVertexPosition'],
  uniforms: ['uSampler'],
});


// some webGL initialization
gl.clearColor(0.0, 0.0, 0.0, 0.0);
gl.clearDepth(1.0);
gl.disable(gl.DEPTH_TEST);



 

var positionsBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionsBuffer);
var positions = vertexPositionData;
gl.bufferData(gl.ARRAY_BUFFER, (positions), gl.STATIC_DRAW);



var verticesIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, verticesIndexBuffer);
var vertexIndices = indexData;
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (vertexIndices), gl.STATIC_DRAW);



var textureCoordAttribute = gl.getAttribLocation(program, "texture");
gl.enableVertexAttribArray(textureCoordAttribute);
var textureBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuf);
var textureBufpositions = textureCoordData;
gl.bufferData(gl.ARRAY_BUFFER, (textureBufpositions), gl.STATIC_DRAW);
gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);


          mat4.scale(mmatrix, mmatrix, vec3.fromValues(0.3, 0.3, 0.3));
          var mmLoc = gl.getUniformLocation(program, "MMatrix");

          
          mat4.translate(vmatrix, vmatrix, vec3.fromValues(0, 0, 0));
          var vmLoc = gl.getUniformLocation(program, "VMatrix");
          gl.uniformMatrix4fv(vmLoc, false, vmatrix);

          
          mat4.perspective(pmatrix, Math.PI/2.5, 1.75, 0.1, 100);
          var pmLoc = gl.getUniformLocation(program, "PMatrix");
          gl.uniformMatrix4fv(pmLoc, false, pmatrix);

texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.bindTexture(gl.TEXTURE_2D, null);

// update the texture from the video
updateTexture = function() {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  // the next line fails in Safari if the video is coming from another domain or subdomain
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB,
                gl.UNSIGNED_BYTE, video);
  gl.bindTexture(gl.TEXTURE_2D, null);
};

// draw stuff in the canvas
drawScene = function() {
  updateTexture();
  gl.useProgram(program);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionsBuffer);
  gl.vertexAttribPointer(attributes['aVertexPosition'], 2, gl.FLOAT, false, 0, 0);

  // Specify the texture to map onto the faces.
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(uniforms['uSampler'], 0);

  // Draw
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, verticesIndexBuffer);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
  // keep looping
 
  requestAnimationFrame(drawScene);
};


</script>